<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ElasticSearch Centos7安装教程]]></title>
    <url>%2F2020%2F02%2F14%2F10-ElasticSearch-Quick-Start%2F</url>
    <content type="text"><![CDATA[ElasticSearch是一个采用Java语言编写搜索服务器，提供了一个分布式多用户的全文搜索引擎，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 环境说明Centos7必须能连接互联网 12[root@localhost ~]# cat /etc/redhat-releaseCentOS Linux release 7.7.1908 (Core) Xshell用来连接Centos主机. 没有的话直接用系统自带的SSH也可以。 安装ElasticSearch前置任务 (雾)由于es不支持以root用户运行，所以需要创建一个普通用户 1[root@localhost ~]# useradd elasticuser 在自己喜欢的目录创建一个es的下载文件夹. 我选择/usr/es 1[root@localhost ~]# mkdir -p /usr/es 因为是用root用户创建的文件夹, elasticuser用户没有权限，所以要更改文件夹的权限 1[root@localhost usr]# chown elasticuser:elasticuser es/ -R 切换成elasticuser用户进行下面的操作 123[root@localhost usr]# su elasticuser[elasticuser@localhost usr]$ whoamielasticuser 准备任务 (大雾)下载es 12[elasticuser@localhost usr]$ cd es[elasticuser@localhost es]$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.0-linux-x86_64.tar.gz 解压 123[elasticuser@localhost es]$ lselasticsearch-7.6.0-linux-x86_64.tar.gz[elasticuser@localhost es]$ tar zxvf elasticsearch-7.6.0-linux-x86_64.tar.gz 修改配置文件 config/jvm.options (非必须, 目的是调整内存占用少一些) 12-Xms512m-Xmx512m config/elasticsearch.yml (重要, 调整不好会导致ElasticSearch启动失败)不要直接复制粘贴, yml格式不允许写注释. 123456network.host: 0.0.0.0 // 修改完毕后可以外网访问cluster.name: "centos-cluster" // 不改就启动起来提示Warningnode.name: "node-1" // 不改就启动起来提示Warningdiscovery.seed_hosts: ["127.0.0.1", "[::1]"] // 不改就启动起来提示Warningcluster.initial_master_nodes: ["node-1"] // 不改就启动起来提示Warning 尝试启动ElasticSearch. 1[elasticuser@localhost elasticsearch-7.6.0]$ ./bin/elasticsearch 不失众望的报错了, 查看一下报错: 解决错误 ([1])遇到错误不慌， 一个个解决，首先是第一个 1[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535] 更改/etc/security/limits.conf, 这个时候要使用root用户更改, 写入以下内容 12* soft nofile 65535* hard nofile 65535 写完是这样的 接着重启一下服务器. 继续解决下一个bug. 解决错误 ([2])重启完， 先看看第一个错误解决了没有 1234[root@localhost ~]# ulimit -Hn65535[root@localhost ~]# ulimit -Sn65535 发现两个返回都是65535，就证明修改生效了。 然后看下一个报错 1[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 修改/etc/sysctl.conf， 添加 1vm.max_map_count=262144 保存退出 并 执行 12[root@localhost bin]# sysctl -pvm.max_map_count = 262144 再切换成elasticuser用户, 去运行es. 可以看到运行成功了, 使用浏览器去访问http://&lt;centos的IP地址&gt;:9200 emm 无法访问… 因为Centos默认开启了防火墙. 可以直接关闭防火墙 (启停服务需要root用户) 1[root@localhost bin]$ systemctl stop firewalld.service 再重新运行es. ok, 安装完毕, 接下来就可以正常学习和使用ElasticSearch了。 就这样！]]></content>
      <categories>
        <category>Linux</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下配置Flutter运行开发环境]]></title>
    <url>%2F2019%2F12%2F19%2F9-Windows-Set-FlutterDev%2F</url>
    <content type="text"><![CDATA[Windows下设置Flutter的运行开发环境. 说实话, 看到移动平台的开发就觉得很麻烦，还好这次Flutter没让我太过于失望。 下载必要的软件 GIt For Windows Git工具, 在windows下的客户端. Java Java JDK8 Android Studio 是为了安装SDK. Flutter 肯定是下载最新版本啦. VS Code 超级轻量的代码编辑器 设置环境变量Java设置环境变量将JDK的安装目录放入环境变量 key: JAVA_HOME value: D:\Software\Java\jdk1.8.0_231 看个人情况. Flutter设置环境变量将下载的Flutter SDK解压, 放入没有中文，没有空格的目录下, 设置环境变量将Flutter放入系统变量key: FLUTTER_HOME value: D:\LearningMaterials\flutter然后设置PATH: %FLUTTER_HOME%\bin 即可. VSCode安装插件 Dart Flutter 检查运行环境doctorcmd下运行flutter doctor会自动诊断当前的环境是否有异常 emulatorscmd下运行flutter emulators会列出当前可用的Android和IOS设备.通过运行flutter emulators --launch &lt;emulator id&gt;指定列出的设备名, 即可打开设备. runcmd在代码根目录运行flutter run即可在运行的设备中打开APP, 不过第一次可能会出现未license的错误, 可以运行flutter doctor --android-licenses, 根据提示全部按y, 结束后再次flutter run即可成功运行. 学习…学习…]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Windows</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF 密码学思路WriteUP]]></title>
    <url>%2F2019%2F12%2F03%2F8-BUUCTF-Crypto-WriteUP%2F</url>
    <content type="text"><![CDATA[BUUCTF, 自己学习的过程中思路记录, 以及flag… (目的是记录自己的思路和想法！！！) 题目地址: BUUCTF MD5直接拿去SOMD5解密flag{admin1} 看我回旋踢ROT13解密, 直接在线工具.flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1} Url编码用Hackbar之类的工具进行URL解码flag{and 1=1} 摩丝这可不是丝wa… 用工具直接解摩斯电码吧.工具: 摩尔斯电码解密flag{iloveyou} 一眼就解密打开F12, 在Console中输入 1atob("ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=") flag{THE_FLAG_OF_THIS_STRING} 变异凯撒没思路先写脚本穷举, 发现从ascii+5开始依次出现flag关键字, 于是写脚本进行解密. 123456789cipher = "afZ_r9VYfScOeO_UL^RWUc"index = 0for num in range(5, len(cipher) + 5): temp = "" for i in cipher: temp += chr(ord(i) + num) print(temp[index], end="") index += 1 flag{Caesar_variation} Quoted-printable工具题，没意义，也没难度，知道有这种编码就会解.在线工具flag{那你也很棒哦} password社工题目, 之前做过类似的, 知道规律就行, 没什么难度. (别问为什么, 这就是CTF)flag{zs19900315} zip伪加密感觉不应该是密码学, 应该是Misc题目.使用WinHex把压缩包打开, 将Hex的, 50 4B 03 04 14 00 09 00改成50 4B 03 04 14 00 00 00, 保存再去解压, 就会发现可以正常解压了.flag{Adm1N-B2G-kU-SZIP} RSA稍微了解一下RSA加密算法就知道d怎么求了, 直接上py脚本. 12345import libnump = 473398607161q = 4511491e = 17print(libnum.invmod(e, (p - 1) * (q - 1))) flag{125631357777427553} Rabbit看题目就知道是什么加密, 直接找在线工具.flag{Cute_Rabbit} 丢失的MD5给了一个Python脚本, 脚本是Python2的, 直接运行得到Flag. (目的是了解MD5爆破)flag{e9032994dabac08080091151380478a2} 篱笆墙的影子栅栏密码, 选择2栏, 进行加密操作, flag直接出. (注意是加密, 不是解密)flag{wethinkwehavetheflag} Alice与Bob通过在线工具进行质因数分解, 得到两个素数, 根据题目, 将小素数放在前面, 大素数放在后面, 拼接, 进行md5 32位的加密.flag{d450209323a847c8d01c6be47c81811a} rsarsa需要了解RSA的加密过程, 才会知道解密过程, 背脚本是没有意义的。建议去看看RSA原理, 推荐几个我看过的教程.RSA-1RSA-2 看完上面两个绝对会RSA基础题目解密了.上Python脚本!! 123456789import libnump = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034d = libnum.invmod(e, (p-1)*(q-1))result = pow(c, d, p*q)print(result) flag{5577446633554466577768879988} 传统知识+古典密码？这什么沙雕题目，如果看不懂辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳， +甲子就GG.得出: XZSDMFLZ然后进行古典密码解密, 先4栏栅栏, 再偏移21位凯撒, 即可得出FLagflag{SHUANGYU} 大帝的密码武器说实话, 这个题目一开始我没怎么看明白, 后来找到规律就好办了.先将FRPHEVGL进行ASCII爆破, 看题目说会出现有意义的单词, 就每次爆破的时候, ASCII大于z的时候， 将当前字母的ASCII码进行-26操作, 爆破发现13是有意义SECURITY的, 直接上脚本. 12345678910111213141516171819202122232425262728293031cipher = "FRPHEVGL" # 已知的密文result = "SECURITY" # 第一步找到的有意义单词secert = 13 # 第二步找到的有意义偏移量t = "ComeChina" # 需要解密的密文# 1. 爆破具体是位移多少位才是有意义的.for i in range(26): for j in cipher: temp = ord(j) + i if temp &gt; ord("Z"): temp -= 26 print(chr(temp), end="") print()# 2. 找规律, 发现都是根据13来的.temp = []for i, j in zip(cipher, result): i = ord(i) j = ord(j) if i &gt; j: temp.append(j - i) else: temp.append(j - i)print(temp)# 3. 根据题目规律爆破, 超过z就-26, 即可得到Flagfor i in t: t = ord(i) + secert if t &gt; ord("z"): t -= 26 print(chr(t), end="") flag{PbzrPuvan} Windows系统密码下载下来附件拿去Kali使用John工具进行解密. 12john pass.hashjohn --show --format=LM pass.hash 有点坑, 要小写.flag{good-luck} RSA1已知dp,dq求解: 题目给了dp, dq, 需要去了解一下dp,dq是什么, 然后直接脚本做题. 12345678import libnumimport binasciidef decrypt(dp,dq,p,q,c): InvQ = libnum.invmod(q,p) mp = pow(c,dp,p) mq = pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print (binascii.unhexlify(hex(m)[2:])) flag{W31c0m3_70_Ch1n470wn} RSA3题目给了两个c, 两个e, 一个n, 典型的RSA共模攻击, 直接一把梭. 1234567891011121314151617181920212223import libnumimport binasciidef RSACommonMode(n, c1, c2, e1, e2): def egcd(a, b): if b == 0: return a, 0 else: x, y = egcd(b, a % b) return y, x - (a // b) * y s = egcd(e1, e2) s1 = s[0] s2 = s[1] if s1 &lt; 0: s1 = - s1 c1 = libnum.invmod(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = libnum.invmod(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n print(binascii.unhexlify(hex(m)[2:])) flag{49d91077a1abcb14f1a9d546c80be9ef} 凯撒？替换？呵呵!一堆看不懂的乱码, 扔去quipqiup进行字符频率统计, 就可以得到flag了. 大坑, 空格要删除掉.flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake} 先到这里吧. 以后慢慢补充.]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>BUUCTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手算正反十进制转换二进制过程]]></title>
    <url>%2F2019%2F10%2F28%2F7-Dec-to-Bin-Calc%2F</url>
    <content type="text"><![CDATA[学习一下手算十进制到二进制, 包括正数和负数转换二进制. 十进制正数 转换 二进制 除以2的整数结果除以2到0为止. 结果从下往上看. Example: 把9计算成2进制. 12345699/2 = 4 -&gt; 1 ; 9/2=4.5 把小数点忽略, 就是4, 因为有小数点, 所以这个位置就是1.4/2 = 2 -&gt; 0 ; 4/2=2 没有小数点, 这个位置就是0.2/2 = 1 -&gt; 0 ; 结果等于1的时候还要进行除.1/2 = 0 -&gt; 1 ; 结果为0的时候才能结束, 1/2=0.5, 有余数, 所以为1.从下向上看, 排序1001, 这个计算的结果从上到下和从下到上都一样... Example: 把27计算2进制. 12345672727/2 = 13 -&gt; 113/2 = 6 -&gt; 16/2 = 3 -&gt; 03/2 = 1 -&gt; 11/2 = 0 -&gt; 1结果是: 0001 1011 十进制负数 转换 二进制 计算负数绝对值的二进制结果. 将第一步计算的结果进行取反. 取反后+1, 就是最终结果 64位的, 计算的内容前面填充1. Example: 把-9转换二进制 123456789101199/2 4 14/2 2 02/2 1 01/2 0 1源码: 1001反码: 0110补码: 反码 + 1 : 0111结果: 0111 Example: 把-15转换二进制 12345678910111515/2 7 17/2 3 13/2 1 11/2 0 1源码: 1111反码: 0000补码: 0001结果: 0001 其他数计算都是这个步骤, 去尝试一下吧~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim编程语言快速入门 (附代码例子)]]></title>
    <url>%2F2019%2F10%2F03%2F6-Nim-Programming-Language%2F</url>
    <content type="text"><![CDATA[Nim是一种静态类型编译的系统编程语言, 它结合了其他成熟语言的成功概念, 这次就带你5分钟学会Nim的编写, 来跟我一起尝试一下吧. Nim官网: https://Nim-lang.org/Nim中文社区: https://Nim-lang-cn.org/ 前言花了半小时的时间去试了试这门语言, 可以通过Nim生成js或者c的代码以及可执行文件, 感觉蛮酷的, 做个分享. 基础Nim编译出一个exe文件是这么做的: 1Nim c main.Nim Nim 编译出一个js文件是这么做的: 1Nim js main.Nim 发没发现? 只需要更改Nim 中的内容就可以了. 不过, 你无法编译成”世界上最好的语言”, 比如Nim php main.Nim, 会报错的！！ 超级详细带代码体验定义变量基本变量类型12345# 指定类型var name: string = "HelloWorld"# 类型推断var i = 10 列表(数组)1var list = @[1,2,3,4,5] 加上@符号表明是动态数组, 可以进行Add和POP操作. Table(在Py叫Dict, Go叫Map)12345import tablesvar dict = &#123;"one": "HeliantHuS"&#125;.toTable# 取值echo dict["one"] # HeliantHuS 注释12# 打印HelloWorldecho "HelloWorld" Nim中的注释和Python一样. 判断case-of123456789101112var name: string = readLine(stdin)# case就等于其他语言的switch, of就相当于casecase nameof "": echo "你不可以输入空的哦."of "HeliantHuS": echo "HeliantHuS is Handsome"else: echo "我没看懂你输入的是什么" if-elif-else12345678import strformatvar name: string = readLine(stdin)if name == "HeliantHuS": echo fmt"Hello, &#123;name&#125;"elif name == "exit": echo "Exit!!!"else: echo "没有匹配~" 循环whilewhile 没什么好说的, Python有的它也有. 12while true: echo &quot;Hello&quot; for12345for i in countup(1, 10): echo ifor i in 1..10: echo i 上面两段代码效果一样, 可以看出来比Python还要简洁. 函数定义一个函数123import strformatproc hello(name: string): string = return fmt"Hello, &#123;name&#125;" 调用函数12var result = hello("HeliantHuS")echo result 舍弃函数返回值1discard hello("HeliantHuS") 在Nim中, 函数必须要有返回值, 你就必须要去用变量去接收或者直接echo, 不然会报错, 有时候函数的返回值也许不重要, 就需要去舍弃, 就要用关键字discard去舍弃. 作用域block12block hello: echo "HelloWorld" Nim中也是使用缩进进行作用域的区分. 道理我都懂, 可我好像真的对你着迷.]]></content>
      <categories>
        <category>Nim</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理骚操作详解]]></title>
    <url>%2F2019%2F10%2F03%2F5-Nginx-Config-ServerName%2F</url>
    <content type="text"><![CDATA[Nginx是一个的静态文件和反向代理服务，轻量，方便部署，而且性能极高.看完这篇文章, 你将点亮NGINX配置虚拟主机, 反向代理等技能点. 深入浅出1234567891011121314151617181920212223worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; &#125;&#125; 上面这是一个nginx最基本的配置, 分http代码块, server代码块, 其中今天要玩的就是server这个代码块. 开始操作首先在nginx的静态文件夹保证有两个html文件, 分别为index.html、page1.html, 里面的内容自己随便写, 只要能分清楚是哪个文件就好. 正常启动正常启动Nginx, 访问通过服务器地址访问, 会访问到index.html的内容. 虚拟主机第一个server代码块不需要更改, 下面紧接着添加: 12345678server &#123; listen 80; server_name page1.com; location / &#123; root html; index page1.html; &#125;&#125; 这样, 只要访问这个服务器的时候，请求头的Host键内容为page1.com, 可以通过抓包或者修改hosts文件的方式来达到目的. 反向代理第二个server代码块不需要更改, 修改第一个server代码块的内容为: 1234567server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://hls.easy.echosite.cn/; &#125;&#125; 重启服务器, 访问localhost或者服务器真实IP, 你会发现, 显示的结果是你输入的http://hls.easy.echosite.cn的内容, 但是浏览器的URL依旧是localhost或服务器IP. 防盗链配置原理: 通过nginx的if判断, 只允许通过合法的域名访问本网站, 其余的域名访问本网站的时候直接返回403。 123456789101112server &#123; listen 80; server_name youdoamin.com; if ($host !~* ^youdomain.com$) &#123; return 403; &#125; location / &#123; root html; index index.html index.htm; &#125;&#125; 临了, 最后的配置文件样子: 其实Nginx还有很多脚本类的东西, 太过深入就需要自己去研究了, NGINX一般还是作为接入层的反向代理去使用, 配置方便, 也轻量, 真的是做WEB必备的反向代理服务. 最后~ 文章中演示的hls.easy.echosite.cn是使用EchoSite2.0 内网穿透，就选他了！所内网穿透用来测试的, 如果有需要内网穿透的可以了解一下.]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric Python远程部署利器]]></title>
    <url>%2F2019%2F10%2F01%2F4-Fabric-Python-Remote-deploy%2F</url>
    <content type="text"><![CDATA[Fabric是一个Python的第三方库，可以进行Linux的远程部署，批量执行各种命令，况且，机器出错的次数比你少多了呢。(附详细的SSH免密登录过程) 环境介绍 Windows10的WSL IP: 192.168.1.66 下面简称物理机. VMware Centos服务器 IP: 192.168.1.40 下面简称服务器. 准备工作 Python3 类Linux操作系统 | 没有Linux用Windows的WSL也可以. 技术难点 SSH免密登录. 深入浅出SSH免密使用ssh-keygen命令在物理机生成公钥和私钥, 生成完毕后在当前登录的用户目录下.ssh文件夹下. 在服务器中的.ssh文件夹下创建一个名为authorized_keys文件并设置权限为600. 123cd ~/.sshtouch authorized_keyschmod 600 authorized_keys 将物理机的id_rsa.pub里面的内容复制进服务器新建的authorized_keys中.可以使用scp命令，将id_rsa.pub文件发送到服务器中，然后使用cat命令将id_rsa.pub的内容追加到authorized_keys文件中.物理机: 1scp ~/.ssh/id_rsa.pub root@192.168.1.40:~/.ssh/ 服务器: 1cat id_rsa.pub &gt;&gt; authorized_keys 使用物理机远程SSH连接服务器验证是否免密成功 安装Fabric在物理机执行下面的安装命令即可安装完毕. 1python3 -m pip install fabric 找一个空的目录新建名为fabfile.py的文件. 编写Fabric脚本使用vim编辑刚刚新建的py文件. 12345from fabric import Connection, task@taskdef devploy(c): with Connection("root@192.168.1.40") as c: c.run("ifconfig") 写入完毕后保存，运行fab deploy即可看到服务器的执行回显. 可以用来一键替换更新yum源, 代码如下: 1234567891011from fabric import Connection, task@taskdef deploy(c): with Connection("root@192.168.1.40") as c: c.run('cd /etc/yum.repos.d/ &amp;&amp; \ mv CentOS-Media.repo CentOS-Media.repo.backup &amp;&amp; \ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;&amp; \ yum clean all &amp;&amp; \ yum makecache &amp;&amp; \ yum update') 不是不愿意学习新的东西, 而是想知道学习这个能做什么, 加油.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>fabric</tag>
        <tag>远程部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nessus系统漏洞扫描平台(VMware傻瓜式安装)]]></title>
    <url>%2F2019%2F09%2F30%2F3-Nessus-Install-or-Use-and-License%2F</url>
    <content type="text"><![CDATA[最懊恼的就是安装这种软件了，免费版本只能扫描16个IP，收费版本在天朝没人会去买，买完也没人去分享，而现在，我来安利一波可以无限IP，而且还傻瓜式的Nessus安装方式. 准备工具 VMware Workstation (Version &gt;= 12) 科学上网工具 眼睛和脑子 下载Nessus(VMware版)https://mega.nz/#!0YkSDYpY!JndpKpH5yB3hDNV-091jOwPhW9rLK9iNSzuF9nTz-i0 部署Nessus导入至VMware首先解压下载的压缩文件，放到你能记得住的地方 然后打开vmware, File -&gt; Open, 选择Nessus 8_VM12.ovf文件. 开机运行 配置网卡默认的用户名和密码都在描述中写了, 按照描述进行操作绝对没问题的. 开机你肯定没问题了，按照他的要求访问https://1.1.2.1:8834你肯定访问不了，你需要修改网卡配置 这样，将网卡2改成NAT 就可以自动获取IP地址, 获取完毕直接输入ifconfig查看自动获取的IP地址, 访问自动获取的IP地址加端口号…哦对了, 一定要是https, 比如我自动获取的IP地址为192.168.23.134, 那么我在我物理机访问https://192.168.23.134:8834就可以了. 到这里就完全可以正常运行以及进行扫描了, 怎么运行扫描就要看你了, 赶紧继续学习吧~]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>扫描</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paramiko Python远程连接工具]]></title>
    <url>%2F2019%2F09%2F29%2F2-paramiko-remote-exec%2F</url>
    <content type="text"><![CDATA[Paramiko是一个Python的远程操作库，可以进行SSH, SFTP等远程连接操作. 来学习学习怎么使用吧 安装Paramiko1python3 -m pip install paramiko 开始使用导入paramiko1import paramiko 初始化SSHClient12client = paramiko.SSHClient()client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 连接主机我的Linux主机是192.168.1.40，用户名为root, 密码为admin123. 1client.connect(hostname="192.168.1.40", username="root", password="admin123.") 连接上会有几条警告，可以无视掉，或者直接屏蔽警告信息 发送命令执行一个ifconfig命令 1stdin, stdout, stderr = client.exec_command("ifconfig") 注意这里, exec_command的返回值为tuple类型可以通过python3 -m pydoc paramiko.SSHClient.exec_command查看源码. 查看命令返回值12for i in stdout.readlines(): print(i) 这样就得到了返回值 关闭连接不要总是依赖上下文, 要学会手动释放资源关闭连接 1client.close() 到这里, paramiko的SSHClient用法就结束了，paramiko还支持SFTPClient等其他远程操作, 自己发掘吧~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Reverse (简单的逆向)]]></title>
    <url>%2F2019%2F09%2F28%2F1-Simple-Reverse%2F</url>
    <content type="text"><![CDATA[学习使用IDA Pro 和 x64dbg反编译一个C语言程序. 准备工具 DevC++ IDA Pro x64dbg 开始动手！我直接做成了视频. 直接来看吧.【逆向工程】IDA Pro + x64dgb反编译一个应用程序]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
</search>
