<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BUUCTF 密码学思路WriteUP]]></title>
    <url>%2F2019%2F12%2F03%2F8-BUUCTF-Crypto-WriteUP%2F</url>
    <content type="text"><![CDATA[MD5直接拿去SOMD5解密flag{admin1} 看我回旋踢ROT13解密, 直接在线工具.flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1} Url编码用Hackbar之类的工具进行URL解码flag{and 1=1} 摩丝这可不是丝wa… 用工具直接解摩斯电码吧.工具: 摩尔斯电码解密flag{iloveyou} 一眼就解密打开F12, 在Console中输入 1atob("ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30=") flag{THE_FLAG_OF_THIS_STRING} 变异摩斯没思路先写脚本穷举, 发现从ascii+5开始依次出现flag关键字, 于是写脚本进行解密. 123456789cipher = "afZ_r9VYfScOeO_UL^RWUc"index = 0for num in range(5, len(cipher) + 5): temp = "" for i in cipher: temp += chr(ord(i) + num) print(temp[index], end="") index += 1 flag{Caesar_variation} Quoted-printable工具题，没意义，也没难度，知道有这种编码就会解.在线工具flag{那你也很棒哦} password社工题目, 之前做过类似的, 知道规律就行, 没什么难度. (别问为什么, 这就是CTF)flag{zs19900315} zip伪加密感觉不应该是密码学, 应该是Misc题目.使用WinHex把压缩包打开, 将Hex的, 50 4B 03 04 14 00 09 00改成50 4B 03 04 14 00 00 00, 保存再去解压, 就会发现可以正常解压了.flag{Adm1N-B2G-kU-SZIP} RSA稍微了解一下RSA加密算法就知道d怎么求了, 直接上py脚本. 12345import libnump = 473398607161q = 4511491e = 17print(libnum.invmod(e, (p - 1) * (q - 1))) flag{125631357777427553} Rabbit看题目就知道是什么加密, 直接找在线工具.flag{Cute_Rabbit} 丢失的MD5给了一个Python脚本, 脚本是Python2的, 直接运行得到Flag. (目的是了解MD5爆破)flag{e9032994dabac08080091151380478a2} 篱笆墙的影子栅栏密码, 选择2栏, 进行加密操作, flag直接出. (注意是加密, 不是解密)flag{wethinkwehavetheflag} Alice与Bob通过在线工具进行质因数分解, 得到两个素数, 根据题目, 将小素数放在前面, 大素数放在后面, 拼接, 进行md5 32位的加密.flag{d450209323a847c8d01c6be47c81811a} rsarsa需要了解RSA的加密过程, 才会知道解密过程, 背脚本是没有意义的。建议去看看RSA原理, 推荐几个我看过的教程.RSA-1RSA-2 看完上面两个绝对会RSA基础题目解密了.上Python脚本!! 123456789import libnump = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034d = libnum.invmod(e, (p-1)*(q-1))result = pow(c, d, p*q)print(result) flag{5577446633554466577768879988} 传统知识+古典密码？这什么沙雕题目，如果看不懂辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳， +甲子就GG.得出: XZSDMFLZ然后进行古典密码解密, 先4栏栅栏, 再偏移21位凯撒, 即可得出FLagflag{SHUANGYU} 大帝的密码武器说实话, 这个题目一开始我没怎么看明白, 后来找到规律就好办了.先将FRPHEVGL进行ASCII爆破, 看题目说会出现有意义的单词, 就每次爆破的时候, ASCII大于’z’的时候， 将当前字母的ASCII码进行-26操作, 爆破发现13是有意义SECUR的, 直接上脚本. 12345678910111213141516171819202122232425262728293031cipher = "FRPHEVGL" # 已知的密文result = "SECURITY" # 第一步找到的有意义单词secert = 13 # 第二步找到的有意义偏移量t = "ComeChina" # 需要解密的密文# 1. 爆破具体是位移多少位才是有意义的.for i in range(26): for j in cipher: temp = ord(j) + i if temp &gt; ord("Z"): temp -= 26 print(chr(temp), end="") print()# 2. 找规律, 发现都是根据13来的.temp = []for i, j in zip(cipher, result): i = ord(i) j = ord(j) if i &gt; j: temp.append(j - i) else: temp.append(j - i)print(temp)# 3. 根据题目规律爆破, 超过z就-26, 即可得到Flagfor i in t: t = ord(i) + secert if t &gt; ord("z"): t -= 26 print(chr(t), end="") flag{PbzrPuvan} 先到这里吧. 以后慢慢补充.]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>BUUCTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手算正反十进制转换二进制过程]]></title>
    <url>%2F2019%2F10%2F28%2F7-Dec-to-Bin-Calc%2F</url>
    <content type="text"><![CDATA[学习一下手算十进制到二进制, 包括正数和负数转换二进制. 十进制正数 转换 二进制 除以2的整数结果除以2到0为止. 结果从下往上看. Example: 把9计算成2进制. 12345699/2 = 4 -&gt; 1 ; 9/2=4.5 把小数点忽略, 就是4, 因为有小数点, 所以这个位置就是1.4/2 = 2 -&gt; 0 ; 4/2=2 没有小数点, 这个位置就是0.2/2 = 1 -&gt; 0 ; 结果等于1的时候还要进行除.1/2 = 0 -&gt; 1 ; 结果为0的时候才能结束, 1/2=0.5, 有余数, 所以为1.从下向上看, 排序1001, 这个计算的结果从上到下和从下到上都一样... Example: 把27计算2进制. 12345672727/2 = 13 -&gt; 113/2 = 6 -&gt; 16/2 = 3 -&gt; 03/2 = 1 -&gt; 11/2 = 0 -&gt; 1结果是: 0001 1011 十进制负数 转换 二进制 计算负数绝对值的二进制结果. 将第一步计算的结果进行取反. 取反后+1, 就是最终结果 64位的, 计算的内容前面填充1. Example: 把-9转换二进制 123456789101199/2 4 14/2 2 02/2 1 01/2 0 1源码: 1001反码: 0110补码: 反码 + 1 : 0111结果: 0111 Example: 把-15转换二进制 12345678910111515/2 7 17/2 3 13/2 1 11/2 0 1源码: 1111反码: 0000补码: 0001结果: 0001 其他数计算都是这个步骤, 去尝试一下吧~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim编程语言快速入门 (附代码例子)]]></title>
    <url>%2F2019%2F10%2F03%2F6-Nim-Programming-Language%2F</url>
    <content type="text"><![CDATA[Nim是一种静态类型编译的系统编程语言, 它结合了其他成熟语言的成功概念, 这次就带你5分钟学会Nim的编写, 来跟我一起尝试一下吧. Nim官网: https://Nim-lang.org/Nim中文社区: https://Nim-lang-cn.org/ 前言花了半小时的时间去试了试这门语言, 可以通过Nim生成js或者c的代码以及可执行文件, 感觉蛮酷的, 做个分享. 基础Nim编译出一个exe文件是这么做的: 1Nim c main.Nim Nim 编译出一个js文件是这么做的: 1Nim js main.Nim 发没发现? 只需要更改Nim 中的内容就可以了. 不过, 你无法编译成”世界上最好的语言”, 比如Nim php main.Nim, 会报错的！！ 超级详细带代码体验定义变量基本变量类型12345# 指定类型var name: string = "HelloWorld"# 类型推断var i = 10 列表(数组)1var list = @[1,2,3,4,5] 加上@符号表明是动态数组, 可以进行Add和POP操作. Table(在Py叫Dict, Go叫Map)12345import tablesvar dict = &#123;"one": "HeliantHuS"&#125;.toTable# 取值echo dict["one"] # HeliantHuS 注释12# 打印HelloWorldecho "HelloWorld" Nim中的注释和Python一样. 判断case-of123456789101112var name: string = readLine(stdin)# case就等于其他语言的switch, of就相当于casecase nameof "": echo "你不可以输入空的哦."of "HeliantHuS": echo "HeliantHuS is Handsome"else: echo "我没看懂你输入的是什么" if-elif-else12345678import strformatvar name: string = readLine(stdin)if name == "HeliantHuS": echo fmt"Hello, &#123;name&#125;"elif name == "exit": echo "Exit!!!"else: echo "没有匹配~" 循环whilewhile 没什么好说的, Python有的它也有. 12while true: echo &quot;Hello&quot; for12345for i in countup(1, 10): echo ifor i in 1..10: echo i 上面两段代码效果一样, 可以看出来比Python还要简洁. 函数定义一个函数123import strformatproc hello(name: string): string = return fmt"Hello, &#123;name&#125;" 调用函数12var result = hello("HeliantHuS")echo result 舍弃函数返回值1discard hello("HeliantHuS") 在Nim中, 函数必须要有返回值, 你就必须要去用变量去接收或者直接echo, 不然会报错, 有时候函数的返回值也许不重要, 就需要去舍弃, 就要用关键字discard去舍弃. 作用域block12block hello: echo "HelloWorld" Nim中也是使用缩进进行作用域的区分. 道理我都懂, 可我好像真的对你着迷.]]></content>
      <categories>
        <category>Nim</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理骚操作详解]]></title>
    <url>%2F2019%2F10%2F03%2F5-Nginx-Config-ServerName%2F</url>
    <content type="text"><![CDATA[Nginx是一个的静态文件和反向代理服务，轻量，方便部署，而且性能极高.看完这篇文章, 你将点亮NGINX配置虚拟主机, 反向代理等技能点. 深入浅出1234567891011121314151617181920212223worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; &#125;&#125; 上面这是一个nginx最基本的配置, 分http代码块, server代码块, 其中今天要玩的就是server这个代码块. 开始操作首先在nginx的静态文件夹保证有两个html文件, 分别为index.html、page1.html, 里面的内容自己随便写, 只要能分清楚是哪个文件就好. 正常启动正常启动Nginx, 访问通过服务器地址访问, 会访问到index.html的内容. 虚拟主机第一个server代码块不需要更改, 下面紧接着添加: 12345678server &#123; listen 80; server_name page1.com; location / &#123; root html; index page1.html; &#125;&#125; 这样, 只要访问这个服务器的时候，请求头的Host键内容为page1.com, 可以通过抓包或者修改hosts文件的方式来达到目的. 反向代理第二个server代码块不需要更改, 修改第一个server代码块的内容为: 1234567server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://hls.easy.echosite.cn/; &#125;&#125; 重启服务器, 访问localhost或者服务器真实IP, 你会发现, 显示的结果是你输入的http://hls.easy.echosite.cn的内容, 但是浏览器的URL依旧是localhost或服务器IP. 防盗链配置原理: 通过nginx的if判断, 只允许通过合法的域名访问本网站, 其余的域名访问本网站的时候直接返回403。 123456789101112server &#123; listen 80; server_name youdoamin.com; if ($host !~* ^youdomain.com$) &#123; return 403; &#125; location / &#123; root html; index index.html index.htm; &#125;&#125; 临了, 最后的配置文件样子: 其实Nginx还有很多脚本类的东西, 太过深入就需要自己去研究了, NGINX一般还是作为接入层的反向代理去使用, 配置方便, 也轻量, 真的是做WEB必备的反向代理服务. 最后~ 文章中演示的hls.easy.echosite.cn是使用EchoSite2.0 内网穿透，就选他了！所内网穿透用来测试的, 如果有需要内网穿透的可以了解一下.]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric Python远程部署利器]]></title>
    <url>%2F2019%2F10%2F01%2F4-Fabric-Python-Remote-deploy%2F</url>
    <content type="text"><![CDATA[Fabric是一个Python的第三方库，可以进行Linux的远程部署，批量执行各种命令，况且，机器出错的次数比你少多了呢。(附详细的SSH免密登录过程) 环境介绍 Windows10的WSL IP: 192.168.1.66 下面简称物理机. VMware Centos服务器 IP: 192.168.1.40 下面简称服务器. 准备工作 Python3 类Linux操作系统 | 没有Linux用Windows的WSL也可以. 技术难点 SSH免密登录. 深入浅出SSH免密使用ssh-keygen命令在物理机生成公钥和私钥, 生成完毕后在当前登录的用户目录下.ssh文件夹下. 在服务器中的.ssh文件夹下创建一个名为authorized_keys文件并设置权限为600. 123cd ~/.sshtouch authorized_keyschmod 600 authorized_keys 将物理机的id_rsa.pub里面的内容复制进服务器新建的authorized_keys中.可以使用scp命令，将id_rsa.pub文件发送到服务器中，然后使用cat命令将id_rsa.pub的内容追加到authorized_keys文件中.物理机: 1scp ~/.ssh/id_rsa.pub root@192.168.1.40:~/.ssh/ 服务器: 1cat id_rsa.pub &gt;&gt; authorized_keys 使用物理机远程SSH连接服务器验证是否免密成功 安装Fabric在物理机执行下面的安装命令即可安装完毕. 1python3 -m pip install fabric 找一个空的目录新建名为fabfile.py的文件. 编写Fabric脚本使用vim编辑刚刚新建的py文件. 12345from fabric import Connection, task@taskdef devploy(c): with Connection("root@192.168.1.40") as c: c.run("ifconfig") 写入完毕后保存，运行fab deploy即可看到服务器的执行回显. 可以用来一键替换更新yum源, 代码如下: 1234567891011from fabric import Connection, task@taskdef deploy(c): with Connection("root@192.168.1.40") as c: c.run('cd /etc/yum.repos.d/ &amp;&amp; \ mv CentOS-Media.repo CentOS-Media.repo.backup &amp;&amp; \ wget http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;&amp; \ yum clean all &amp;&amp; \ yum makecache &amp;&amp; \ yum update') 不是不愿意学习新的东西, 而是想知道学习这个能做什么, 加油.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>fabric</tag>
        <tag>远程部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nessus系统漏洞扫描平台(VMware傻瓜式安装)]]></title>
    <url>%2F2019%2F09%2F30%2F3-Nessus-Install-or-Use-and-License%2F</url>
    <content type="text"><![CDATA[最懊恼的就是安装这种软件了，免费版本只能扫描16个IP，收费版本在天朝没人会去买，买完也没人去分享，而现在，我来安利一波可以无限IP，而且还傻瓜式的Nessus安装方式. 准备工具 VMware Workstation (Version &gt;= 12) 科学上网工具 眼睛和脑子 下载Nessus(VMware版)https://mega.nz/#!0YkSDYpY!JndpKpH5yB3hDNV-091jOwPhW9rLK9iNSzuF9nTz-i0 部署Nessus导入至VMware首先解压下载的压缩文件，放到你能记得住的地方 然后打开vmware, File -&gt; Open, 选择Nessus 8_VM12.ovf文件. 开机运行 配置网卡默认的用户名和密码都在描述中写了, 按照描述进行操作绝对没问题的. 开机你肯定没问题了，按照他的要求访问https://1.1.2.1:8834你肯定访问不了，你需要修改网卡配置 这样，将网卡2改成NAT 就可以自动获取IP地址, 获取完毕直接输入ifconfig查看自动获取的IP地址, 访问自动获取的IP地址加端口号…哦对了, 一定要是https, 比如我自动获取的IP地址为192.168.23.134, 那么我在我物理机访问https://192.168.23.134:8834就可以了. 到这里就完全可以正常运行以及进行扫描了, 怎么运行扫描就要看你了, 赶紧继续学习吧~]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>扫描</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paramiko Python远程连接工具]]></title>
    <url>%2F2019%2F09%2F29%2F2-paramiko-remote-exec%2F</url>
    <content type="text"><![CDATA[Paramiko是一个Python的远程操作库，可以进行SSH, SFTP等远程连接操作. 来学习学习怎么使用吧 安装Paramiko1python3 -m pip install paramiko 开始使用导入paramiko1import paramiko 初始化SSHClient12client = paramiko.SSHClient()client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 连接主机我的Linux主机是192.168.1.40，用户名为root, 密码为admin123. 1client.connect(hostname="192.168.1.40", username="root", password="admin123.") 连接上会有几条警告，可以无视掉，或者直接屏蔽警告信息 发送命令执行一个ifconfig命令 1stdin, stdout, stderr = client.exec_command("ifconfig") 注意这里, exec_command的返回值为tuple类型可以通过python3 -m pydoc paramiko.SSHClient.exec_command查看源码. 查看命令返回值12for i in stdout.readlines(): print(i) 这样就得到了返回值 关闭连接不要总是依赖上下文, 要学会手动释放资源关闭连接 1client.close() 到这里, paramiko的SSHClient用法就结束了，paramiko还支持SFTPClient等其他远程操作, 自己发掘吧~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>paramiko</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Reverse (简单的逆向)]]></title>
    <url>%2F2019%2F09%2F28%2F1-Simple-Reverse%2F</url>
    <content type="text"><![CDATA[学习使用IDA Pro 和 x64dbg反编译一个C语言程序. 准备工具 DevC++ IDA Pro x64dbg 开始动手！我直接做成了视频. 直接来看吧.【逆向工程】IDA Pro + x64dgb反编译一个应用程序]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
</search>
